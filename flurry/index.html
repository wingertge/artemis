<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `flurry` crate."><meta name="keywords" content="rust, rustlang, rust-lang, flurry"><title>flurry - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../flurry/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate flurry</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all flurry's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'flurry', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/flurry/lib.rs.html#1-234' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>flurry</a></span></h1><div class='docblock'><p>A concurrent hash table based on Java's <code>ConcurrentHashMap</code>.</p>
<p>A hash table that supports full concurrency of retrievals and high expected concurrency for
updates. This type is functionally very similar to <code>std::collections::HashMap</code>, and for the
most part has a similar API. Even though all operations on the map are thread-safe and operate
on shared references, retrieval operations do <em>not</em> entail locking, and there is <em>not</em> any
support for locking the entire table in a way that prevents all access.</p>
<h1 id="a-note-on-guard-and-memory-use" class="section-header"><a href="#a-note-on-guard-and-memory-use">A note on <code>Guard</code> and memory use</a></h1>
<p>You may have noticed that many of the access methods on this map take a reference to an
<a href="../flurry/epoch/struct.Guard.html" title="`epoch::Guard`"><code>epoch::Guard</code></a>. The exact details of this are beyond the scope of this documentation (for
that, see <a href="https://docs.rs/crossbeam/0.7/crossbeam/epoch/index.html"><code>crossbeam::epoch</code></a>), but some of the implications bear repeating here. You obtain a
<code>Guard</code> using <a href="../flurry/epoch/fn.pin.html" title="`epoch::pin`"><code>epoch::pin</code></a>, and you can use references to the same guard to make multiple API
calls if you wish. Whenever you get a reference to something stored in the map, that reference
is tied to the lifetime of the <code>Guard</code> that you provided. This is because each <code>Guard</code> prevents
the destruction of any item associated with it. Whenever something is read under a <code>Guard</code>,
that something stays around for <em>at least</em> as long as the <code>Guard</code> does. The map delays
deallocating values until it safe to do so, and in order to amortize the cost of the necessary
bookkeeping it may delay even further until there's a <em>batch</em> of items that need to be
deallocated.</p>
<p>Notice that there is a trade-off here. Creating and dropping a <code>Guard</code> is not free, since it
also needs to interact with said bookkeeping. But if you keep one around for a long time, you
may accumulate much garbage which will take up valuable free memory on your system. Use your
best judgement in deciding whether or not to re-use a <code>Guard</code>. This is also the reason why the
map requires that <code>K: 'static</code> and <code>V: 'static</code>. If we did not, then your keys and values may
get dropped far later, potentially after those lifetimes have passed, which would not be sound.</p>
<h1 id="consistency" class="section-header"><a href="#consistency">Consistency</a></h1>
<p>Retrieval operations (including <a href="../flurry/struct.HashMap.html#method.get"><code>get</code></a>) generally do not block, so may
overlap with update operations (including <a href="../flurry/struct.HashMap.html#method.insert"><code>insert</code></a>). Retrievals
reflect the results of the most recently <em>completed</em> update operations holding upon their
onset. (More formally, an update operation for a given key bears a <em>happens-before</em> relation
with any successful retrieval for that key reporting the updated value.)</p>
<p>Operations that inspect the map as a whole, rather than a single key, operate on a snapshot of
the underlying table. For example, iterators return elements reflecting the state of the hash
table at some point at or since the creation of the iterator. Aggregate status methods like
<a href="../flurry/struct.HashMap.html#method.len"><code>len</code></a> are typically useful only when a map is not undergoing concurrent
updates in other threads. Otherwise the results of these methods reflect transient states that
may be adequate for monitoring or estimation purposes, but not for program control.
Similarly, <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html"><code>Clone</code></a> may not produce a &quot;perfect&quot; clone if the underlying
map is being concurrently modified.</p>
<h1 id="resizing-behavior" class="section-header"><a href="#resizing-behavior">Resizing behavior</a></h1>
<p>The table is dynamically expanded when there are too many collisions (i.e., keys that have
distinct hash codes but fall into the same slot modulo the table size), with the expected
average effect of maintaining roughly two bins per mapping (corresponding to a 0.75 load factor
threshold for resizing). There may be much variance around this average as mappings are added
and removed, but overall, this maintains a commonly accepted time/space tradeoff for hash
tables.  However, resizing this or any other kind of hash table may be a relatively slow
operation. When possible, it is a good idea to provide a size estimate by using the
<a href="../flurry/struct.HashMap.html#method.with_capacity"><code>with_capacity</code></a> constructor. Note that using many keys with
exactly the same <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html"><code>Hash</code></a> value is a sure way to slow down performance of any
hash table.</p>
<h1 id="implementation-notes" class="section-header"><a href="#implementation-notes">Implementation notes</a></h1>
<p>This data-structure is a pretty direct port of Java's <code>java.util.concurrent.ConcurrentHashMap</code>
<a href="http://gee.cs.oswego.edu/dl/concurrency-interest/">from Doug Lea and the rest of the JSR166
team</a>. Huge thanks to them for releasing the
code into the public domain! Much of the documentation is also lifted from there. What follows
is a slightly modified version of their implementation notes from within the <a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.java?view=markup">source
file</a>.</p>
<p>The primary design goal of this hash table is to maintain concurrent readability (typically
method <code>get()</code>, but also iterators and related methods) while minimizing update contention.
Secondary goals are to keep space consumption about the same or better than java.util.HashMap,
and to support high initial insertion rates on an empty table by many threads.</p>
<p>This map usually acts as a binned (bucketed) hash table.  Each key-value mapping is held in a
<code>BinEntry</code>.  Most nodes are of type <code>BinEntry::Node</code> with hash, key, value, and a <code>next</code> field.
However, some nodes are of type <code>BinEntry::Moved</code>; these &quot;forwarding nodes&quot; are placed at the
heads of bins during resizing. The Java version also has other special node types, but these
have not yet been implemented in this port. These special nodes are all either uncommon or
transient.</p>
<p>The table is lazily initialized to a power-of-two size upon the first insertion.  Each bin in
the table normally contains a list of nodes (most often, the list has only zero or one
<code>BinEntry</code>). Table accesses require atomic reads, writes, and CASes.</p>
<p>Insertion (via <code>put</code>) of the first node in an empty bin is performed by just CASing it to the
bin.  This is by far the most common case for put operations under most key/hash distributions.
Other update operations (insert, delete, and replace) require locks.  We do not want to waste
the space required to associate a distinct lock object with each bin, so we instead embed a
lock inside each node, and use the lock in the the first node of a bin list as the lock for the
bin.</p>
<p>Using the first node of a list as a lock does not by itself suffice though: When a node is
locked, any update must first validate that it is still the first node after locking it, and
retry if not. Because new nodes are always appended to lists, once a node is first in a bin, it
remains first until deleted or the bin becomes invalidated (upon resizing).</p>
<p>The main disadvantage of per-bin locks is that other update operations on other nodes in a bin
list protected by the same lock can stall, for example when user <code>Eq</code> implementations or
mapping functions take a long time.  However, statistically, under random hash codes, this is
not a common problem.  Ideally, the frequency of nodes in bins follows a Poisson distribution
(http://en.wikipedia.org/wiki/Poisson_distribution) with a parameter of about 0.5 on average,
given the resizing threshold of 0.75, although with a large variance because of resizing
granularity. Ignoring variance, the expected occurrences of list size <code>k</code> are <code>exp(-0.5) * pow(0.5, k) / factorial(k)</code>. The first values are:</p>
<pre><code class="language-text">0:    0.60653066
1:    0.30326533
2:    0.07581633
3:    0.01263606
4:    0.00157952
5:    0.00015795
6:    0.00001316
7:    0.00000094
8:    0.00000006
more: less than 1 in ten million
</code></pre>
<p>Lock contention probability for two threads accessing distinct elements is roughly <code>1 / (8 * #elements)</code> under random hashes.</p>
<p>Actual hash code distributions encountered in practice sometimes deviate significantly from
uniform randomness.  This includes the case when <code>N &gt; (1&lt;&lt;30)</code>, so some keys MUST collide.
Similarly for dumb or hostile usages in which multiple keys are designed to have identical hash
codes or ones that differs only in masked-out high bits. Here, the Java implementation uses an
optimization where a bin is turned into a binary tree, but this has not yet been ported over to
the Rust version.</p>
<p>The table is resized when occupancy exceeds a percentage threshold (nominally, 0.75, but see
below).  Any thread noticing an overfull bin may assist in resizing after the initiating thread
allocates and sets up the replacement array. However, rather than stalling, these other threads
may proceed with insertions etc. Resizing proceeds by transferring bins, one by one, from the
table to the next table. However, threads claim small blocks of indices to transfer (via the
field <code>transfer_index</code>) before doing so, reducing contention.  A generation stamp in the field
<code>size_ctl</code> ensures that resizings do not overlap. Because we are using power-of-two expansion,
the elements from each bin must either stay at same index, or move with a power of two offset.
We eliminate unnecessary node creation by catching cases where old nodes can be reused because
their next fields won't change.  On average, only about one-sixth of them need cloning when a
table doubles. The nodes they replace will be garbage collectible as soon as they are no longer
referenced by any reader thread that may be in the midst of concurrently traversing table.
Upon transfer, the old table bin contains only a special forwarding node (<code>BinEntry::Moved</code>)
that contains the next table as its key. On encountering a forwarding node, access and update
operations restart, using the new table.</p>
<p>Each bin transfer requires its bin lock, which can stall waiting for locks while resizing.
However, because other threads can join in and help resize rather than contend for locks,
average aggregate waits become shorter as resizing progresses.  The transfer operation must
also ensure that all accessible bins in both the old and new table are usable by any traversal.
This is arranged in part by proceeding from the last bin <code>table.length - 1</code> up towards the
first.  Upon seeing a forwarding node, traversals (see <code>iter::traverser::Traverser</code>) arrange to
move to the new table without revisiting nodes.  To ensure that no intervening nodes are
skipped even when moved out of order, a stack (see class <code>iter::traverser::TableStack</code>) is
created on first encounter of a forwarding node during a traversal, to maintain its place if
later processing the current table. The need for these save/restore mechanics is relatively
rare, but when one forwarding node is encountered, typically many more will be. So <code>Traversers</code>
use a simple caching scheme to avoid creating so many new <code>TableStack</code> nodes. (Thanks to Peter
Levart for suggesting use of a stack here.)</p>
<h2 id="garbage-collection" class="section-header"><a href="#garbage-collection">Garbage collection</a></h2>
<p>The Java implementation can rely on Java's runtime garbage collection to safely deallocate
deleted or removed nodes, keys, and values. Since Rust does not have such a runtime, we must
ensure through some other mechanism that we do not drop values before all references to them
have goen away. We do this using <a href="https://docs.rs/crossbeam/0.7/crossbeam/epoch/index.html"><code>crossbeam::epoch</code></a>, which provides an implementation of an
epoch-based garbae collection scheme. This forces us to make certain API changes such as
requiring <code>Guard</code> arguments to many methods or wrapping the return values, but provides much
more efficient operation than if everything had to be atomically reference-counted.</p>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="epoch/index.html" title='flurry::epoch mod'>epoch</a></td><td class='docblock-short'><p>Types needed to safely access shared data concurrently.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="iter/index.html" title='flurry::iter mod'>iter</a></td><td class='docblock-short'><p>Iterator types.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.HashMap.html" title='flurry::HashMap struct'>HashMap</a></td><td class='docblock-short'><p>A concurrent hash table.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.HashMapRef.html" title='flurry::HashMapRef struct'>HashMapRef</a></td><td class='docblock-short'><p>A reference to a <a href="../flurry/struct.HashMap.html" title="`HashMap`"><code>HashMap</code></a>, constructed with <a href="../flurry/struct.HashMap.html#method.pin" title="`HashMap::pin`"><code>HashMap::pin</code></a> or <a href="../flurry/struct.HashMap.html#method.with_guard" title="`HashMap::with_guard`"><code>HashMap::with_guard</code></a>.</p>
</td></tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table><tr class='module-item'><td><a class="type" href="type.DefaultHashBuilder.html" title='flurry::DefaultHashBuilder type'>DefaultHashBuilder</a></td><td class='docblock-short'><p>Default hasher for <a href="../flurry/struct.HashMap.html" title="`HashMap`"><code>HashMap</code></a>.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "flurry";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>