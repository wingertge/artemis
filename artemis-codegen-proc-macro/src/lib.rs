use artemis_codegen::wasm::{wasm_client as generate, WasmClientInput};
use proc_macro::TokenStream;

/// Generate a WASM client wrapper that gets exported in your WASM binary
/// This is required because WASM doesn't support generics and the regular
/// Client uses a lot of them. It will hard-code your exchanges, as well
/// as other options you may pass to the macro.
///
/// Additional options can be passed from JavaScript, only exchanges and the query enum are required.
/// The query enum is generated by `artemis-build` and is located in the root of your query module.
/// Make sure this is located in a WASM-only module or annotate it with #[cfg(target_arch = "wasm32")]
///
/// # Usage
///
/// ```ignore
/// use artemis::wasm_client;
/// use artemis::exchanges::{DedupExchange, CacheExchange, FetchExchange};
/// use artemis_test::queries::wasm::Queries;
///
/// wasm_client! {
///     exchanges: [
///         DedupExchange,
///         CacheExchange,
///         FetchExchange
///     ],
///     url: "my_url",
///     queries: Queries
/// }
/// ```
#[proc_macro]
pub fn wasm_client(tokens: TokenStream) -> TokenStream {
    let input = syn::parse_macro_input!(tokens as WasmClientInput);
    generate(input).into()
}
