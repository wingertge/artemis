initSidebarItems({"attr":[["ast_node","Alias for `#[derive(Spanned, Fold, Clone, Debug, PartialEq)]` for a struct and `#[derive(Spanned, Fold, Clone, Debug, PartialEq, FromVariant)]` for an enum."]],"constant":[["DUMMY_SP","Dummy span, both position and length are zero, syntax context is zero as well."],["NO_EXPANSION",""]],"derive":[["DeserializeEnum",""],["Fold","Implements `FoldWith<F>` and `VisitWith<F>`."],["FromVariant",""],["Spanned",""]],"enum":[["FileName","Differentiates between real files and common virtual files."],["SpanLinesError",""],["SpanSnippetError",""]],"macro":[["add_bitflags","rustfmt-friendly version of `bitblags!`."],["impl_stable_hash_via_hash",""],["rustc_erase_owner",""]],"mod":[["comments",""],["errors",""],["hygiene","Machinery for hygienic macros, inspired by the `MTWT[1]` paper."],["input",""],["iter",""],["macros",""],["pass",""],["serializer",""],["util",""]],"static":[["GLOBALS",""]],"struct":[["BytePos","A byte offset. Keep this small (currently 32-bits), as AST contains a lot of them."],["CharPos","A character offset. Because of multibyte utf8 characters, a byte offset is not equivalent to a character offset. The SourceMap will convert BytePos values to CharPos values as necessary."],["FileLines",""],["FilePathMapping",""],["Globals",""],["LineCol","Used to create a `.map` file."],["Loc","A source code location used for error reporting"],["LocWithOpt","A source code location used as the result of lookup_char_pos_adj"],["Mark","A mark is a unique id associated with a macro expansion."],["MultiSpan","A collection of spans. Spans have two orthogonal attributes:"],["SourceFile","A single source in the SourceMap."],["SourceFileAndBytePos",""],["SourceFileAndLine",""],["SourceMap",""],["Span","A compressed span."],["SpanData","Spans represent a region of code, used for error reporting. Positions in spans are absolute positions from the beginning of the source_map, not positions relative to SourceFiles. Methods on the SourceMap can be used to relate spans back to the original source. You must be careful if the span crosses more than one file - you will not be able to use many of the functions on spans in source_map and you cannot assume that the length of the span = hi - lo; there may be space in the BytePos range between files."],["SyntaxContext","A SyntaxContext represents a chain of macro expansions (represented by marks)."]],"trait":[["AstNode","A trait for ast nodes."],["FileLoader","An abstraction over the fs operations used by the Parser."],["Spanned","Derive This trait can be derived with `#[derive(Spanned)]`."]]});