<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `artemis` crate."><meta name="keywords" content="rust, rustlang, rust-lang, artemis"><title>artemis - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../artemis/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate artemis</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all artemis's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'artemis', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/artemis/lib.rs.html#1-383' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>artemis</a></span></h1><div class='docblock'><p>A modern GraphQL Client with common built-in features
as well as the ability to extend its functionality through exchanges</p>
<h1 id="getting-started" class="section-header"><a href="#getting-started">Getting Started</a></h1>
<p>The first step is to write some queries in <code>.graphql</code> files and then add the following to your
<code>build.rs</code> (create it if necessary):</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="kw">use</span> <span class="ident">artemis_build</span>::<span class="ident">CodegenBuilder</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="ident">CodegenBuilder</span>::<span class="ident">new</span>()
        .<span class="ident">introspect_schema</span>(<span class="string">&quot;http://localhost:8080/graphql&quot;</span>, <span class="prelude-val">None</span>, <span class="ident">Vec</span>::<span class="ident">new</span>())
        .<span class="ident">unwrap</span>()
        .<span class="ident">add_query</span>(<span class="string">&quot;queries/x.graphql&quot;</span>)
        .<span class="ident">with_out_dir</span>(<span class="string">&quot;src/queries&quot;</span>)
        .<span class="ident">build</span>()
        .<span class="ident">unwrap</span>();
}</pre></div>
<p>Afterwards, you can use the crate in your application as such:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">artemis</span>::<span class="ident">Client</span>;
<span class="kw">use</span> <span class="ident">artemis_test</span>::<span class="ident">get_conference</span>::{<span class="ident">GetConference</span>, <span class="ident">get_conference</span>::<span class="ident">Variables</span>};

<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">Client</span>::<span class="ident">builder</span>(<span class="string">&quot;http://localhost:8080/graphql&quot;</span>)
    .<span class="ident">with_default_exchanges</span>()
    .<span class="ident">build</span>();

<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">client</span>.<span class="ident">query</span>(<span class="ident">GetConference</span>, <span class="ident">Variables</span> { <span class="ident">id</span>: <span class="string">&quot;1&quot;</span>.<span class="ident">to_string</span>() }).<span class="kw">await</span>.<span class="ident">unwrap</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">result</span>.<span class="ident">data</span>.<span class="ident">is_some</span>());</pre></div>
<p>For more info see the relevant method and struct documentation.</p>
<h1 id="build" class="section-header"><a href="#build">Build</a></h1>
<p>This crate uses code generation to take your GraphQL files and turn them into
strongly typed Rust modules. These contain the query struct, a zero-size type
such as <code>GetConference</code>, as well as a submodule containing the <code>Variables</code>,
any input types, the <code>ResponseData</code> type and any involved output types.</p>
<p>Having a strongly typed compile time representation with additional info
(such as the <code>__typename</code> of all involved types and an abstract selection tree)
means that the work the CPU has to do at runtime is very minimal,
only amounting to serialization, deserialization and simple lookups using
the statically generated data.</p>
<p>For details on how to use the query builder, see <a href="../artemis_build/index.html">artemis-build</a></p>
<h1 id="exchanges" class="section-header"><a href="#exchanges">Exchanges</a></h1>
<p>Exchanges are like a bi-directional middleware.
They act on both the incoming and outgoing queries,
passing them on if they can't return a result themselves.</p>
<p>There are three default exchanges, called in this order:</p>
<h2 id="dedupexchange" class="section-header"><a href="#dedupexchange">DedupExchange</a></h2>
<p>The deduplication exchange (<code>DedupExchange</code>) filters out unnecessary queries
by combining multiple identical queries into one. It does so by keeping track
of in-flight queries and, instead of firing off another identical query,
waiting for their results instead. This reduces network traffic,
especially in larger applications where the same query may be used in multiple
places and run multiple times simultaneously as a result.</p>
<h2 id="cacheexchange" class="section-header"><a href="#cacheexchange">CacheExchange</a></h2>
<p>The cache exchange is a very basic, un-normalized cache which eagerly invalidates queries.
It's focused on simplicity and correctness of data, so if a query uses any of the same types
as a mutation it will always be invalidated by it. This means that especially if you
have large amounts of different entities of the same type, this can become expensive quickly.
For a more advanced normalized cache that invalidates only directly related entities
see the <code>artemis-normalized-cache</code> crate.</p>
<h2 id="fetchexchange" class="section-header"><a href="#fetchexchange">FetchExchange</a></h2>
<p>The fetch exchange will serialize the query, send it over the network and deserialize the response.
This works on x86 using <code>reqwest</code>, or <code>fetch</code> if you're using WASM.
This should be your last exchange in the chain, as it never forwards a query.</p>
<h1 id="wasm" class="section-header"><a href="#wasm">WASM</a></h1>
<p>WASM support requires some minor boilerplate in your code.
First, there's a <code>wasm</code> module in your queries. this contains an automatically generated enum
containing all your queries. This is used for transmitting type data across the WASM
boundary.</p>
<p>Second, you have to use the <a href="../artemis_codegen_proc_macro/macro.wasm_client!.html">wasm_client! macro</a>
to generate a WASM interop client that has hard-coded types for your queries, again, to
eliminate the unsupported generics and transmit type data across the boundary.
The queries type passed to the macro must be the enum generated as mentioned above.</p>
<p>Documentation of the JavaScript types and methods can be found in the TypeScript
definitions that are output when you build your WASM.</p>
<h1 id="features" class="section-header"><a href="#features">Features</a></h1>
<ul>
<li><code>default-exchanges</code> <strong>(default)</strong> - Include default exchanges and the related builder method</li>
<li><code>observable</code> <strong>(default)</strong> - Include support for observable and all related types. Includes
<code>tokio</code> on x86.</li>
</ul>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use client::<a class="struct" href="../artemis/client/struct.Client.html" title="struct artemis::client::Client">Client</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="client/index.html" title='artemis::client mod'>client</a></td><td class='docblock-short'><p>Contains client-related types.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="codegen/index.html" title='artemis::codegen mod'>codegen</a></td><td class='docblock-short'><p>Types used only by the code generator. Exchanges may use these, but they shouldn't
be created/implemented manually.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="default_exchanges/index.html" title='artemis::default_exchanges mod'>default_exchanges</a></td><td class='docblock-short'><p>This module contains the default exchanges.
Note that these require the <code>default-exchanges</code> feature.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="exchange/index.html" title='artemis::exchange mod'>exchange</a></td><td class='docblock-short'><p>Types used by custom exchanges. Regular users probably don't need these.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="utils/index.html" title='artemis::utils mod'>utils</a></td><td class='docblock-short'><p>Contains utility functions mainly used internally, but they're public for use in
exchanges and macros.</p>
</td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.ext.html" title='artemis::ext macro'>ext</a></td><td class='docblock-short'><p>Creates a new <code>ExtensionMap</code> and fills it with the passed values.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.wasm_client.html" title='artemis::wasm_client macro'>wasm_client</a></td><td class='docblock-short'><p>Generate a WASM client wrapper that gets exported in your WASM binary
This is required because WASM doesn't support generics and the regular
Client uses a lot of them. It will hard-code your exchanges, as well
as other options you may pass to the macro.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.ClientBuilder.html" title='artemis::ClientBuilder struct'>ClientBuilder</a></td><td class='docblock-short'><p>A builder for the artemis client.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.DebugInfo.html" title='artemis::DebugInfo struct'>DebugInfo</a></td><td class='docblock-short'><p>Debug info used for... well, debugging.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Error.html" title='artemis::Error struct'>Error</a></td><td class='docblock-short'><p>An element in the top-level <code>errors</code> array of a response body.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.ExtensionMap.html" title='artemis::ExtensionMap struct'>ExtensionMap</a></td><td class='docblock-short'><p>A map of keyed extensions.
The key is only used for JS interop,
the Rust version uses the type as the key.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.HeaderPair.html" title='artemis::HeaderPair struct'>HeaderPair</a></td><td class='docblock-short'><p>A key-value pair used for custom headers.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Location.html" title='artemis::Location struct'>Location</a></td><td class='docblock-short'><p>Represents a location inside a query string. Used in errors. See <a href="./struct.Error.html">Error</a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Observable.html" title='artemis::Observable struct'>Observable</a></td><td class='docblock-short'><p>An observable result. This implements <code>Stream</code> and unsubscribes on drop.
It will receive early (partial or stale) results, as well as refreshing when the query is
rerun after being invalidated by mutations.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.QueryBody.html" title='artemis::QueryBody struct'>QueryBody</a></td><td class='docblock-short'><p>The form in which queries are sent over HTTP in most implementations. This will be built using the <a href="./trait.GraphQLQuery.html">GraphQLQuery</a> trait normally.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.QueryError.html" title='artemis::QueryError struct'>QueryError</a></td><td class='docblock-short'><p>A query error wrapper that allows for cheap and easy cloning across threads.
If a <code>std::error::Error</code> is needed, use <code>QueryError.compat()</code>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.QueryOptions.html" title='artemis::QueryOptions struct'>QueryOptions</a></td><td class='docblock-short'><p>Options that can be passed to a query.
This will be combined with <code>ClientOptions</code>, but <code>QueryOptions</code> takes precedence.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Response.html" title='artemis::Response struct'>Response</a></td><td class='docblock-short'><p>The generic shape taken by the responses of GraphQL APIs.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.PathFragment.html" title='artemis::PathFragment enum'>PathFragment</a></td><td class='docblock-short'><p>Part of a path in a query. It can be an object key or an array index. See <a href="./struct.Error.html">Error</a>.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.RequestPolicy.html" title='artemis::RequestPolicy enum'>RequestPolicy</a></td><td class='docblock-short'><p>The request policy of the request.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.ResultSource.html" title='artemis::ResultSource enum'>ResultSource</a></td><td class='docblock-short'><p>The source of the result (cache or network).
Used for debugging.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.GraphQLQuery.html" title='artemis::GraphQLQuery trait'>GraphQLQuery</a></td><td class='docblock-short'><p>A convenience trait that can be used to build a GraphQL request body.
This will be implemented for you by codegen. It is implemented on the struct you place the derive on.</p>
</td></tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table><tr class='module-item'><td><a class="type" href="type.Extensions.html" title='artemis::Extensions type'>Extensions</a></td><td class='docblock-short'><p>A thread-safe wrapper around <a href="./struct.ExtensionMap.html">ExtensionMap</a>.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "artemis";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>