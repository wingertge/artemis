initSidebarItems({"constant":[["_CMP_EQ_OQ","Equal (ordered, non-signaling)"],["_CMP_EQ_OS","Equal (ordered, signaling)"],["_CMP_EQ_UQ","Equal (unordered, non-signaling)"],["_CMP_EQ_US","Equal (unordered, signaling)"],["_CMP_FALSE_OQ","False (ordered, non-signaling)"],["_CMP_FALSE_OS","False (ordered, signaling)"],["_CMP_GE_OQ","Greater-than-or-equal (ordered, non-signaling)"],["_CMP_GE_OS","Greater-than-or-equal (ordered, signaling)"],["_CMP_GT_OQ","Greater-than (ordered, non-signaling)"],["_CMP_GT_OS","Greater-than (ordered, signaling)"],["_CMP_LE_OQ","Less-than-or-equal (ordered, non-signaling)"],["_CMP_LE_OS","Less-than-or-equal (ordered, signaling)"],["_CMP_LT_OQ","Less-than (ordered, non-signaling)"],["_CMP_LT_OS","Less-than (ordered, signaling)"],["_CMP_NEQ_OQ","Not-equal (ordered, non-signaling)"],["_CMP_NEQ_OS","Not-equal (ordered, signaling)"],["_CMP_NEQ_UQ","Not-equal (unordered, non-signaling)"],["_CMP_NEQ_US","Not-equal (unordered, signaling)"],["_CMP_NGE_UQ","Not-greater-than-or-equal (unordered, non-signaling)"],["_CMP_NGE_US","Not-greater-than-or-equal (unordered, signaling)"],["_CMP_NGT_UQ","Not-greater-than (unordered, non-signaling)"],["_CMP_NGT_US","Not-greater-than (unordered, signaling)"],["_CMP_NLE_UQ","Not-less-than-or-equal (unordered, non-signaling)"],["_CMP_NLE_US","Not-less-than-or-equal (unordered, signaling)"],["_CMP_NLT_UQ","Not-less-than (unordered, non-signaling)"],["_CMP_NLT_US","Not-less-than (unordered, signaling)"],["_CMP_ORD_Q","Ordered (non-signaling)"],["_CMP_ORD_S","Ordered (signaling)"],["_CMP_TRUE_UQ","True (unordered, non-signaling)"],["_CMP_TRUE_US","True (unordered, signaling)"],["_CMP_UNORD_Q","Unordered (non-signaling)"],["_CMP_UNORD_S","Unordered (signaling)"],["_MM_EXCEPT_DENORM","See `_mm_setcsr`"],["_MM_EXCEPT_DIV_ZERO","See `_mm_setcsr`"],["_MM_EXCEPT_INEXACT","See `_mm_setcsr`"],["_MM_EXCEPT_INVALID","See `_mm_setcsr`"],["_MM_EXCEPT_MASK","See `_MM_GET_EXCEPTION_STATE`"],["_MM_EXCEPT_OVERFLOW","See `_mm_setcsr`"],["_MM_EXCEPT_UNDERFLOW","See `_mm_setcsr`"],["_MM_FLUSH_ZERO_MASK","See `_MM_GET_FLUSH_ZERO_MODE`"],["_MM_FLUSH_ZERO_OFF","See `_mm_setcsr`"],["_MM_FLUSH_ZERO_ON","See `_mm_setcsr`"],["_MM_FROUND_CEIL","round up and do not suppress exceptions"],["_MM_FROUND_CUR_DIRECTION","use MXCSR.RC; see `vendor::_MM_SET_ROUNDING_MODE`"],["_MM_FROUND_FLOOR","round down and do not suppress exceptions"],["_MM_FROUND_NEARBYINT","use MXCSR.RC and suppress exceptions; see `vendor::_MM_SET_ROUNDING_MODE`"],["_MM_FROUND_NINT","round to nearest and do not suppress exceptions"],["_MM_FROUND_NO_EXC","suppress exceptions"],["_MM_FROUND_RAISE_EXC","do not suppress exceptions"],["_MM_FROUND_RINT","use MXCSR.RC and do not suppress exceptions; see `vendor::_MM_SET_ROUNDING_MODE`"],["_MM_FROUND_TO_NEAREST_INT","round to nearest"],["_MM_FROUND_TO_NEG_INF","round down"],["_MM_FROUND_TO_POS_INF","round up"],["_MM_FROUND_TO_ZERO","truncate"],["_MM_FROUND_TRUNC","truncate and do not suppress exceptions"],["_MM_HINT_NTA","See `_mm_prefetch`."],["_MM_HINT_T0","See `_mm_prefetch`."],["_MM_HINT_T1","See `_mm_prefetch`."],["_MM_HINT_T2","See `_mm_prefetch`."],["_MM_MASK_DENORM","See `_mm_setcsr`"],["_MM_MASK_DIV_ZERO","See `_mm_setcsr`"],["_MM_MASK_INEXACT","See `_mm_setcsr`"],["_MM_MASK_INVALID","See `_mm_setcsr`"],["_MM_MASK_MASK","See `_MM_GET_EXCEPTION_MASK`"],["_MM_MASK_OVERFLOW","See `_mm_setcsr`"],["_MM_MASK_UNDERFLOW","See `_mm_setcsr`"],["_MM_ROUND_DOWN","See `_mm_setcsr`"],["_MM_ROUND_MASK","See `_MM_GET_ROUNDING_MODE`"],["_MM_ROUND_NEAREST","See `_mm_setcsr`"],["_MM_ROUND_TOWARD_ZERO","See `_mm_setcsr`"],["_MM_ROUND_UP","See `_mm_setcsr`"],["_SIDD_BIT_MASK","Mask only: return the bit mask"],["_SIDD_CMP_EQUAL_ANY","For each character in `a`, find if it is in `b` (Default)"],["_SIDD_CMP_EQUAL_EACH","The strings defined by `a` and `b` are equal"],["_SIDD_CMP_EQUAL_ORDERED","Search for the defined substring in the target"],["_SIDD_CMP_RANGES","For each character in `a`, determine if `b[0] <= c <= b[1] or b[1] <= c <= b[2]...`"],["_SIDD_LEAST_SIGNIFICANT","Index only: return the least significant bit (Default)"],["_SIDD_MASKED_NEGATIVE_POLARITY","Negates results only before the end of the string"],["_SIDD_MASKED_POSITIVE_POLARITY","Do not negate results before the end of the string"],["_SIDD_MOST_SIGNIFICANT","Index only: return the most significant bit"],["_SIDD_NEGATIVE_POLARITY","Negates results"],["_SIDD_POSITIVE_POLARITY","Do not negate results (Default)"],["_SIDD_SBYTE_OPS","String contains signed 8-bit characters"],["_SIDD_SWORD_OPS","String contains unsigned 16-bit characters"],["_SIDD_UBYTE_OPS","String contains unsigned 8-bit characters (Default)"],["_SIDD_UNIT_MASK","Mask only: return the byte mask"],["_SIDD_UWORD_OPS","String contains unsigned 16-bit characters"],["_XABORT_CAPACITY","Transaction abort due to the transaction using too much memory."],["_XABORT_CONFLICT","Transaction abort due to a memory conflict with another thread."],["_XABORT_DEBUG","Transaction abort due to a debug trap."],["_XABORT_EXPLICIT","Transaction explicitly aborted with xabort. The parameter passed to xabort is available with `_xabort_code(status)`."],["_XABORT_NESTED","Transaction abort in a inner nested transaction."],["_XABORT_RETRY","Transaction retry is possible."],["_XBEGIN_STARTED","Transaction successfully started."],["_XCR_XFEATURE_ENABLED_MASK","`XFEATURE_ENABLED_MASK` for `XCR`"]],"fn":[["_MM_GET_EXCEPTION_MASK","See `_mm_setcsr`"],["_MM_GET_EXCEPTION_STATE","See `_mm_setcsr`"],["_MM_GET_FLUSH_ZERO_MODE","See `_mm_setcsr`"],["_MM_GET_ROUNDING_MODE","See `_mm_setcsr`"],["_MM_SET_EXCEPTION_MASK","See `_mm_setcsr`"],["_MM_SET_EXCEPTION_STATE","See `_mm_setcsr`"],["_MM_SET_FLUSH_ZERO_MODE","See `_mm_setcsr`"],["_MM_SET_ROUNDING_MODE","See `_mm_setcsr`"],["_MM_SHUFFLE","A utility function for creating masks to use with Intel shuffle and permute intrinsics."],["_MM_TRANSPOSE4_PS","Transpose the 4x4 matrix formed by 4 rows of __m128 in place."],["__cpuid","See `__cpuid_count`."],["__cpuid_count","Returns the result of the `cpuid` instruction for a given `leaf` (`EAX`) and `sub_leaf` (`ECX`)."],["__get_cpuid_max","Returns the highest-supported `leaf` (`EAX`) and sub-leaf (`ECX`) `cpuid` values."],["__rdtscp","Reads the current value of the processorâ€™s time-stamp counter and the `IA32_TSC_AUX MSR`."],["_addcarry_u32","Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in` (carry flag), and store the unsigned 32-bit result in `out`, and the carry-out is returned (carry or overflow flag)."],["_addcarry_u64","Adds unsigned 64-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in` (carry flag), and store the unsigned 64-bit result in `out`, and the carry-out is returned (carry or overflow flag)."],["_addcarryx_u32","Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in` (carry or overflow flag), and store the unsigned 32-bit result in `out`, and the carry-out is returned (carry or overflow flag)."],["_addcarryx_u64","Adds unsigned 64-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in` (carry or overflow flag), and store the unsigned 64-bit result in `out`, and the carry-out is returned (carry or overflow flag)."],["_andn_u32","Bitwise logical `AND` of inverted `a` with `b`."],["_andn_u64","Bitwise logical `AND` of inverted `a` with `b`."],["_bextr2_u32","Extracts bits of `a` specified by `control` into the least significant bits of the result."],["_bextr2_u64","Extracts bits of `a` specified by `control` into the least significant bits of the result."],["_bextr_u32","Extracts bits in range [`start`, `start` + `length`) from `a` into the least significant bits of the result."],["_bextr_u64","Extracts bits in range [`start`, `start` + `length`) from `a` into the least significant bits of the result."],["_bittest","Returns the bit in position `b` of the memory addressed by `p`."],["_bittest64","Returns the bit in position `b` of the memory addressed by `p`."],["_bittestandcomplement","Returns the bit in position `b` of the memory addressed by `p`, then inverts that bit."],["_bittestandcomplement64","Returns the bit in position `b` of the memory addressed by `p`, then inverts that bit."],["_bittestandreset","Returns the bit in position `b` of the memory addressed by `p`, then resets that bit to `0`."],["_bittestandreset64","Returns the bit in position `b` of the memory addressed by `p`, then resets that bit to `0`."],["_bittestandset","Returns the bit in position `b` of the memory addressed by `p`, then sets the bit to `1`."],["_bittestandset64","Returns the bit in position `b` of the memory addressed by `p`, then sets the bit to `1`."],["_blcfill_u32","Clears all bits below the least significant zero bit of `x`."],["_blcfill_u64","Clears all bits below the least significant zero bit of `x`."],["_blci_u32","Sets all bits of `x` to 1 except for the least significant zero bit."],["_blci_u64","Sets all bits of `x` to 1 except for the least significant zero bit."],["_blcic_u32","Sets the least significant zero bit of `x` and clears all other bits."],["_blcic_u64","Sets the least significant zero bit of `x` and clears all other bits."],["_blcmsk_u32","Sets the least significant zero bit of `x` and clears all bits above that bit."],["_blcmsk_u64","Sets the least significant zero bit of `x` and clears all bits above that bit."],["_blcs_u32","Sets the least significant zero bit of `x`."],["_blcs_u64","Sets the least significant zero bit of `x`."],["_blsfill_u32","Sets all bits of `x` below the least significant one."],["_blsfill_u64","Sets all bits of `x` below the least significant one."],["_blsi_u32","Extracts lowest set isolated bit."],["_blsi_u64","Extracts lowest set isolated bit."],["_blsic_u32","Clears least significant bit and sets all other bits."],["_blsic_u64","Clears least significant bit and sets all other bits."],["_blsmsk_u32","Gets mask up to lowest set bit."],["_blsmsk_u64","Gets mask up to lowest set bit."],["_blsr_u32","Resets the lowest set bit of `x`."],["_blsr_u64","Resets the lowest set bit of `x`."],["_bswap","Returns an integer with the reversed byte order of x"],["_bswap64","Returns an integer with the reversed byte order of x"],["_bzhi_u32","Zeroes higher bits of `a` >= `index`."],["_bzhi_u64","Zeroes higher bits of `a` >= `index`."],["_fxrstor","Restores the `XMM`, `MMX`, `MXCSR`, and `x87` FPU registers from the 512-byte-long 16-byte-aligned memory region `mem_addr`."],["_fxrstor64","Restores the `XMM`, `MMX`, `MXCSR`, and `x87` FPU registers from the 512-byte-long 16-byte-aligned memory region `mem_addr`."],["_fxsave","Saves the `x87` FPU, `MMX` technology, `XMM`, and `MXCSR` registers to the 512-byte-long 16-byte-aligned memory region `mem_addr`."],["_fxsave64","Saves the `x87` FPU, `MMX` technology, `XMM`, and `MXCSR` registers to the 512-byte-long 16-byte-aligned memory region `mem_addr`."],["_lzcnt_u32","Counts the leading most significant zero bits."],["_lzcnt_u64","Counts the leading most significant zero bits."],["_m_empty","Empty the MMX state, which marks the x87 FPU registers as available for use by x87 instructions. This instruction must be used at the end of all MMX technology procedures."],["_m_maskmovq","Conditionally copies the values from each 8-bit element in the first 64-bit integer vector operand to the specified memory location, as specified by the most significant bit in the corresponding element in the second 64-bit integer vector operand."],["_m_paddb","Adds packed 8-bit integers in `a` and `b`."],["_m_paddd","Adds packed 32-bit integers in `a` and `b`."],["_m_paddsb","Adds packed 8-bit integers in `a` and `b` using saturation."],["_m_paddsw","Adds packed 16-bit integers in `a` and `b` using saturation."],["_m_paddusb","Adds packed unsigned 8-bit integers in `a` and `b` using saturation."],["_m_paddusw","Adds packed unsigned 16-bit integers in `a` and `b` using saturation."],["_m_paddw","Adds packed 16-bit integers in `a` and `b`."],["_m_pavgb","Computes the rounded averages of the packed unsigned 8-bit integer values and writes the averages to the corresponding bits in the destination."],["_m_pavgw","Computes the rounded averages of the packed unsigned 16-bit integer values and writes the averages to the corresponding bits in the destination."],["_m_pextrw","Extracts 16-bit element from a 64-bit vector of `[4 x i16]` and returns it, as specified by the immediate integer operand."],["_m_pinsrw","Copies data from the 64-bit vector of `[4 x i16]` to the destination, and inserts the lower 16-bits of an integer operand at the 16-bit offset specified by the immediate operand `n`."],["_m_pmaxsw","Compares the packed 16-bit signed integers of `a` and `b` writing the greatest value into the result."],["_m_pmaxub","Compares the packed 8-bit signed integers of `a` and `b` writing the greatest value into the result."],["_m_pminsw","Compares the packed 16-bit signed integers of `a` and `b` writing the smallest value into the result."],["_m_pminub","Compares the packed 8-bit signed integers of `a` and `b` writing the smallest value into the result."],["_m_pmovmskb","Takes the most significant bit from each 8-bit element in a 64-bit integer vector to create a 16-bit mask value. Zero-extends the value to 32-bit integer and writes it to the destination."],["_m_pmulhuw","Multiplies packed 16-bit unsigned integer values and writes the high-order 16 bits of each 32-bit product to the corresponding bits in the destination."],["_m_psadbw","Subtracts the corresponding 8-bit unsigned integer values of the two 64-bit vector operands and computes the absolute value for each of the difference. Then sum of the 8 absolute differences is written to the bits `[15:0]` of the destination; the remaining bits `[63:16]` are cleared."],["_m_pshufw","Shuffles the 4 16-bit integers from a 64-bit integer vector to the destination, as specified by the immediate value operand."],["_m_psubb","Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`."],["_m_psubd","Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`."],["_m_psubsb","Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a` using saturation."],["_m_psubsw","Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a` using saturation."],["_m_psubusb","Subtract packed unsigned 8-bit integers in `b` from packed unsigned 8-bit integers in `a` using saturation."],["_m_psubusw","Subtract packed unsigned 16-bit integers in `b` from packed unsigned 16-bit integers in `a` using saturation."],["_m_psubw","Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`."],["_mm256_abs_epi16","Computes the absolute values of packed 16-bit integers in `a`."],["_mm256_abs_epi32","Computes the absolute values of packed 32-bit integers in `a`."],["_mm256_abs_epi8","Computes the absolute values of packed 8-bit integers in `a`."],["_mm256_add_epi16","Adds packed 16-bit integers in `a` and `b`."],["_mm256_add_epi32","Adds packed 32-bit integers in `a` and `b`."],["_mm256_add_epi64","Adds packed 64-bit integers in `a` and `b`."],["_mm256_add_epi8","Adds packed 8-bit integers in `a` and `b`."],["_mm256_add_pd","Adds packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm256_add_ps","Adds packed single-precision (32-bit) floating-point elements in `a` and `b`."],["_mm256_adds_epi16","Adds packed 16-bit integers in `a` and `b` using saturation."],["_mm256_adds_epi8","Adds packed 8-bit integers in `a` and `b` using saturation."],["_mm256_adds_epu16","Adds packed unsigned 16-bit integers in `a` and `b` using saturation."],["_mm256_adds_epu8","Adds packed unsigned 8-bit integers in `a` and `b` using saturation."],["_mm256_addsub_pd","Alternatively adds and subtracts packed double-precision (64-bit) floating-point elements in `a` to/from packed elements in `b`."],["_mm256_addsub_ps","Alternatively adds and subtracts packed single-precision (32-bit) floating-point elements in `a` to/from packed elements in `b`."],["_mm256_alignr_epi8","Concatenates pairs of 16-byte blocks in `a` and `b` into a 32-byte temporary result, shifts the result right by `n` bytes, and returns the low 16 bytes."],["_mm256_and_pd","Computes the bitwise AND of a packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm256_and_ps","Computes the bitwise AND of packed single-precision (32-bit) floating-point elements in `a` and `b`."],["_mm256_and_si256","Computes the bitwise AND of 256 bits (representing integer data) in `a` and `b`."],["_mm256_andnot_pd","Computes the bitwise NOT of packed double-precision (64-bit) floating-point elements in `a`, and then AND with `b`."],["_mm256_andnot_ps","Computes the bitwise NOT of packed single-precision (32-bit) floating-point elements in `a` and then AND with `b`."],["_mm256_andnot_si256","Computes the bitwise NOT of 256 bits (representing integer data) in `a` and then AND with `b`."],["_mm256_avg_epu16","Averages packed unsigned 16-bit integers in `a` and `b`."],["_mm256_avg_epu8","Averages packed unsigned 8-bit integers in `a` and `b`."],["_mm256_blend_epi16","Blends packed 16-bit integers from `a` and `b` using control mask `imm8`."],["_mm256_blend_epi32","Blends packed 32-bit integers from `a` and `b` using control mask `imm8`."],["_mm256_blend_pd","Blends packed double-precision (64-bit) floating-point elements from `a` and `b` using control mask `imm8`."],["_mm256_blend_ps","Blends packed single-precision (32-bit) floating-point elements from `a` and `b` using control mask `imm8`."],["_mm256_blendv_epi8","Blends packed 8-bit integers from `a` and `b` using `mask`."],["_mm256_blendv_pd","Blends packed double-precision (64-bit) floating-point elements from `a` and `b` using `c` as a mask."],["_mm256_blendv_ps","Blends packed single-precision (32-bit) floating-point elements from `a` and `b` using `c` as a mask."],["_mm256_broadcast_pd","Broadcasts 128 bits from memory (composed of 2 packed double-precision (64-bit) floating-point elements) to all elements of the returned vector."],["_mm256_broadcast_ps","Broadcasts 128 bits from memory (composed of 4 packed single-precision (32-bit) floating-point elements) to all elements of the returned vector."],["_mm256_broadcast_sd","Broadcasts a double-precision (64-bit) floating-point element from memory to all elements of the returned vector."],["_mm256_broadcast_ss","Broadcasts a single-precision (32-bit) floating-point element from memory to all elements of the returned vector."],["_mm256_broadcastb_epi8","Broadcasts the low packed 8-bit integer from `a` to all elements of the 256-bit returned value."],["_mm256_broadcastd_epi32","Broadcasts the low packed 32-bit integer from `a` to all elements of the 256-bit returned value."],["_mm256_broadcastq_epi64","Broadcasts the low packed 64-bit integer from `a` to all elements of the 256-bit returned value."],["_mm256_broadcastsd_pd","Broadcasts the low double-precision (64-bit) floating-point element from `a` to all elements of the 256-bit returned value."],["_mm256_broadcastsi128_si256","Broadcasts 128 bits of integer data from a to all 128-bit lanes in the 256-bit returned value."],["_mm256_broadcastss_ps","Broadcasts the low single-precision (32-bit) floating-point element from `a` to all elements of the 256-bit returned value."],["_mm256_broadcastw_epi16","Broadcasts the low packed 16-bit integer from a to all elements of the 256-bit returned value"],["_mm256_bslli_epi128","Shifts 128-bit lanes in `a` left by `imm8` bytes while shifting in zeros."],["_mm256_bsrli_epi128","Shifts 128-bit lanes in `a` right by `imm8` bytes while shifting in zeros."],["_mm256_castpd128_pd256","Casts vector of type __m128d to type __m256d; the upper 128 bits of the result are undefined."],["_mm256_castpd256_pd128","Casts vector of type __m256d to type __m128d."],["_mm256_castpd_ps","Cast vector of type __m256d to type __m256."],["_mm256_castpd_si256","Casts vector of type __m256d to type __m256i."],["_mm256_castps128_ps256","Casts vector of type __m128 to type __m256; the upper 128 bits of the result are undefined."],["_mm256_castps256_ps128","Casts vector of type __m256 to type __m128."],["_mm256_castps_pd","Cast vector of type __m256 to type __m256d."],["_mm256_castps_si256","Casts vector of type __m256 to type __m256i."],["_mm256_castsi128_si256","Casts vector of type __m128i to type __m256i; the upper 128 bits of the result are undefined."],["_mm256_castsi256_pd","Casts vector of type __m256i to type __m256d."],["_mm256_castsi256_ps","Casts vector of type __m256i to type __m256."],["_mm256_castsi256_si128","Casts vector of type __m256i to type __m128i."],["_mm256_ceil_pd","Rounds packed double-precision (64-bit) floating point elements in `a` toward positive infinity."],["_mm256_ceil_ps","Rounds packed single-precision (32-bit) floating point elements in `a` toward positive infinity."],["_mm256_cmp_pd","Compares packed double-precision (64-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `imm8`."],["_mm256_cmp_ps","Compares packed single-precision (32-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `imm8`."],["_mm256_cmpeq_epi16","Compares packed 16-bit integers in `a` and `b` for equality."],["_mm256_cmpeq_epi32","Compares packed 32-bit integers in `a` and `b` for equality."],["_mm256_cmpeq_epi64","Compares packed 64-bit integers in `a` and `b` for equality."],["_mm256_cmpeq_epi8","Compares packed 8-bit integers in `a` and `b` for equality."],["_mm256_cmpgt_epi16","Compares packed 16-bit integers in `a` and `b` for greater-than."],["_mm256_cmpgt_epi32","Compares packed 32-bit integers in `a` and `b` for greater-than."],["_mm256_cmpgt_epi64","Compares packed 64-bit integers in `a` and `b` for greater-than."],["_mm256_cmpgt_epi8","Compares packed 8-bit integers in `a` and `b` for greater-than."],["_mm256_cvtepi16_epi32","Sign-extend 16-bit integers to 32-bit integers."],["_mm256_cvtepi16_epi64","Sign-extend 16-bit integers to 64-bit integers."],["_mm256_cvtepi32_epi64","Sign-extend 32-bit integers to 64-bit integers."],["_mm256_cvtepi32_pd","Converts packed 32-bit integers in `a` to packed double-precision (64-bit) floating-point elements."],["_mm256_cvtepi32_ps","Converts packed 32-bit integers in `a` to packed single-precision (32-bit) floating-point elements."],["_mm256_cvtepi8_epi16","Sign-extend 8-bit integers to 16-bit integers."],["_mm256_cvtepi8_epi32","Sign-extend 8-bit integers to 32-bit integers."],["_mm256_cvtepi8_epi64","Sign-extend 8-bit integers to 64-bit integers."],["_mm256_cvtepu16_epi32","Zeroes extend packed unsigned 16-bit integers in `a` to packed 32-bit integers, and stores the results in `dst`."],["_mm256_cvtepu16_epi64","Zero-extend the lower four unsigned 16-bit integers in `a` to 64-bit integers. The upper four elements of `a` are unused."],["_mm256_cvtepu32_epi64","Zero-extend unsigned 32-bit integers in `a` to 64-bit integers."],["_mm256_cvtepu8_epi16","Zero-extend unsigned 8-bit integers in `a` to 16-bit integers."],["_mm256_cvtepu8_epi32","Zero-extend the lower eight unsigned 8-bit integers in `a` to 32-bit integers. The upper eight elements of `a` are unused."],["_mm256_cvtepu8_epi64","Zero-extend the lower four unsigned 8-bit integers in `a` to 64-bit integers. The upper twelve elements of `a` are unused."],["_mm256_cvtpd_epi32","Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers."],["_mm256_cvtpd_ps","Converts packed double-precision (64-bit) floating-point elements in `a` to packed single-precision (32-bit) floating-point elements."],["_mm256_cvtph_ps","Converts the 8 x 16-bit half-precision float values in the 128-bit vector `a` into 8 x 32-bit float values stored in a 256-bit wide vector."],["_mm256_cvtps_epi32","Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers."],["_mm256_cvtps_pd","Converts packed single-precision (32-bit) floating-point elements in `a` to packed double-precision (64-bit) floating-point elements."],["_mm256_cvtps_ph","Converts the 8 x 32-bit float values in the 256-bit vector `a` into 8 x 16-bit half-precision float values stored in a 128-bit wide vector."],["_mm256_cvtsd_f64","Returns the first element of the input vector of `[4 x double]`."],["_mm256_cvtsi256_si32","Returns the first element of the input vector of `[8 x i32]`."],["_mm256_cvtss_f32","Returns the first element of the input vector of `[8 x float]`."],["_mm256_cvttpd_epi32","Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers with truncation."],["_mm256_cvttps_epi32","Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers with truncation."],["_mm256_div_pd","Computes the division of each of the 4 packed 64-bit floating-point elements in `a` by the corresponding packed elements in `b`."],["_mm256_div_ps","Computes the division of each of the 8 packed 32-bit floating-point elements in `a` by the corresponding packed elements in `b`."],["_mm256_dp_ps","Conditionally multiplies the packed single-precision (32-bit) floating-point elements in `a` and `b` using the high 4 bits in `imm8`, sum the four products, and conditionally return the sum  using the low 4 bits of `imm8`."],["_mm256_extract_epi16","Extracts a 16-bit integer from `a`, selected with `imm8`. Returns a 32-bit integer containing the zero-extended integer data."],["_mm256_extract_epi32","Extracts a 32-bit integer from `a`, selected with `imm8`."],["_mm256_extract_epi64","Extracts a 64-bit integer from `a`, selected with `imm8`."],["_mm256_extract_epi8","Extracts an 8-bit integer from `a`, selected with `imm8`. Returns a 32-bit integer containing the zero-extended integer data."],["_mm256_extractf128_pd","Extracts 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `a`, selected with `imm8`."],["_mm256_extractf128_ps","Extracts 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from `a`, selected with `imm8`."],["_mm256_extractf128_si256","Extracts 128 bits (composed of integer data) from `a`, selected with `imm8`."],["_mm256_extracti128_si256","Extracts 128 bits (of integer data) from `a` selected with `imm8`."],["_mm256_floor_pd","Rounds packed double-precision (64-bit) floating point elements in `a` toward negative infinity."],["_mm256_floor_ps","Rounds packed single-precision (32-bit) floating point elements in `a` toward negative infinity."],["_mm256_fmadd_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and add the intermediate result to packed elements in `c`."],["_mm256_fmadd_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and add the intermediate result to packed elements in `c`."],["_mm256_fmaddsub_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and alternatively add and subtract packed elements in `c` to/from the intermediate result."],["_mm256_fmaddsub_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and alternatively add and subtract packed elements in `c` to/from the intermediate result."],["_mm256_fmsub_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the intermediate result."],["_mm256_fmsub_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the intermediate result."],["_mm256_fmsubadd_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and alternatively subtract and add packed elements in `c` from/to the intermediate result."],["_mm256_fmsubadd_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and alternatively subtract and add packed elements in `c` from/to the intermediate result."],["_mm256_fnmadd_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to packed elements in `c`."],["_mm256_fnmadd_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to packed elements in `c`."],["_mm256_fnmsub_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result."],["_mm256_fnmsub_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result."],["_mm256_hadd_epi16","Horizontally adds adjacent pairs of 16-bit integers in `a` and `b`."],["_mm256_hadd_epi32","Horizontally adds adjacent pairs of 32-bit integers in `a` and `b`."],["_mm256_hadd_pd","Horizontal addition of adjacent pairs in the two packed vectors of 4 64-bit floating points `a` and `b`. In the result, sums of elements from `a` are returned in even locations, while sums of elements from `b` are returned in odd locations."],["_mm256_hadd_ps","Horizontal addition of adjacent pairs in the two packed vectors of 8 32-bit floating points `a` and `b`. In the result, sums of elements from `a` are returned in locations of indices 0, 1, 4, 5; while sums of elements from `b` are locations 2, 3, 6, 7."],["_mm256_hadds_epi16","Horizontally adds adjacent pairs of 16-bit integers in `a` and `b` using saturation."],["_mm256_hsub_epi16","Horizontally subtract adjacent pairs of 16-bit integers in `a` and `b`."],["_mm256_hsub_epi32","Horizontally subtract adjacent pairs of 32-bit integers in `a` and `b`."],["_mm256_hsub_pd","Horizontal subtraction of adjacent pairs in the two packed vectors of 4 64-bit floating points `a` and `b`. In the result, sums of elements from `a` are returned in even locations, while sums of elements from `b` are returned in odd locations."],["_mm256_hsub_ps","Horizontal subtraction of adjacent pairs in the two packed vectors of 8 32-bit floating points `a` and `b`. In the result, sums of elements from `a` are returned in locations of indices 0, 1, 4, 5; while sums of elements from `b` are locations 2, 3, 6, 7."],["_mm256_hsubs_epi16","Horizontally subtract adjacent pairs of 16-bit integers in `a` and `b` using saturation."],["_mm256_i32gather_epi32","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm256_i32gather_epi64","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm256_i32gather_pd","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm256_i32gather_ps","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm256_i64gather_epi32","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm256_i64gather_epi64","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm256_i64gather_pd","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm256_i64gather_ps","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm256_insert_epi16","Copies `a` to result, and inserts the 16-bit integer `i` into result at the location specified by `index`."],["_mm256_insert_epi32","Copies `a` to result, and inserts the 32-bit integer `i` into result at the location specified by `index`."],["_mm256_insert_epi64","Copies `a` to result, and insert the 64-bit integer `i` into result at the location specified by `index`."],["_mm256_insert_epi8","Copies `a` to result, and inserts the 8-bit integer `i` into result at the location specified by `index`."],["_mm256_insertf128_pd","Copies `a` to result, then inserts 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `b` into result at the location specified by `imm8`."],["_mm256_insertf128_ps","Copies `a` to result, then inserts 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from `b` into result at the location specified by `imm8`."],["_mm256_insertf128_si256","Copies `a` to result, then inserts 128 bits from `b` into result at the location specified by `imm8`."],["_mm256_inserti128_si256","Copies `a` to `dst`, then insert 128 bits (of integer data) from `b` at the location specified by `imm8`."],["_mm256_lddqu_si256","Loads 256-bits of integer data from unaligned memory into result. This intrinsic may perform better than `_mm256_loadu_si256` when the data crosses a cache line boundary."],["_mm256_load_pd","Loads 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into result. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated."],["_mm256_load_ps","Loads 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into result. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated."],["_mm256_load_si256","Loads 256-bits of integer data from memory into result. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated."],["_mm256_loadu2_m128","Loads two 128-bit values (composed of 4 packed single-precision (32-bit) floating-point elements) from memory, and combine them into a 256-bit value. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary."],["_mm256_loadu2_m128d","Loads two 128-bit values (composed of 2 packed double-precision (64-bit) floating-point elements) from memory, and combine them into a 256-bit value. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary."],["_mm256_loadu2_m128i","Loads two 128-bit values (composed of integer data) from memory, and combine them into a 256-bit value. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary."],["_mm256_loadu_pd","Loads 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into result. `mem_addr` does not need to be aligned on any particular boundary."],["_mm256_loadu_ps","Loads 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into result. `mem_addr` does not need to be aligned on any particular boundary."],["_mm256_loadu_si256","Loads 256-bits of integer data from memory into result. `mem_addr` does not need to be aligned on any particular boundary."],["_mm256_madd52hi_epu64","Multiply packed unsigned 52-bit integers in each 64-bit element of `b` and `c` to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`."],["_mm256_madd52lo_epu64","Multiply packed unsigned 52-bit integers in each 64-bit element of `b` and `c` to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`."],["_mm256_madd_epi16","Multiplies packed signed 16-bit integers in `a` and `b`, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers."],["_mm256_maddubs_epi16","Vertically multiplies each unsigned 8-bit integer from `a` with the corresponding signed 8-bit integer from `b`, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers"],["_mm256_mask_i32gather_epi32","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm256_mask_i32gather_epi64","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm256_mask_i32gather_pd","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm256_mask_i32gather_ps","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm256_mask_i64gather_epi32","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm256_mask_i64gather_epi64","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm256_mask_i64gather_pd","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm256_mask_i64gather_ps","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm256_maskload_epi32","Loads packed 32-bit integers from memory pointed by `mem_addr` using `mask` (elements are zeroed out when the highest bit is not set in the corresponding element)."],["_mm256_maskload_epi64","Loads packed 64-bit integers from memory pointed by `mem_addr` using `mask` (elements are zeroed out when the highest bit is not set in the corresponding element)."],["_mm256_maskload_pd","Loads packed double-precision (64-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set)."],["_mm256_maskload_ps","Loads packed single-precision (32-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set)."],["_mm256_maskstore_epi32","Stores packed 32-bit integers from `a` into memory pointed by `mem_addr` using `mask` (elements are not stored when the highest bit is not set in the corresponding element)."],["_mm256_maskstore_epi64","Stores packed 64-bit integers from `a` into memory pointed by `mem_addr` using `mask` (elements are not stored when the highest bit is not set in the corresponding element)."],["_mm256_maskstore_pd","Stores packed double-precision (64-bit) floating-point elements from `a` into memory using `mask`."],["_mm256_maskstore_ps","Stores packed single-precision (32-bit) floating-point elements from `a` into memory using `mask`."],["_mm256_max_epi16","Compares packed 16-bit integers in `a` and `b`, and returns the packed maximum values."],["_mm256_max_epi32","Compares packed 32-bit integers in `a` and `b`, and returns the packed maximum values."],["_mm256_max_epi8","Compares packed 8-bit integers in `a` and `b`, and returns the packed maximum values."],["_mm256_max_epu16","Compares packed unsigned 16-bit integers in `a` and `b`, and returns the packed maximum values."],["_mm256_max_epu32","Compares packed unsigned 32-bit integers in `a` and `b`, and returns the packed maximum values."],["_mm256_max_epu8","Compares packed unsigned 8-bit integers in `a` and `b`, and returns the packed maximum values."],["_mm256_max_pd","Compares packed double-precision (64-bit) floating-point elements in `a` and `b`, and returns packed maximum values"],["_mm256_max_ps","Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and returns packed maximum values"],["_mm256_min_epi16","Compares packed 16-bit integers in `a` and `b`, and returns the packed minimum values."],["_mm256_min_epi32","Compares packed 32-bit integers in `a` and `b`, and returns the packed minimum values."],["_mm256_min_epi8","Compares packed 8-bit integers in `a` and `b`, and returns the packed minimum values."],["_mm256_min_epu16","Compares packed unsigned 16-bit integers in `a` and `b`, and returns the packed minimum values."],["_mm256_min_epu32","Compares packed unsigned 32-bit integers in `a` and `b`, and returns the packed minimum values."],["_mm256_min_epu8","Compares packed unsigned 8-bit integers in `a` and `b`, and returns the packed minimum values."],["_mm256_min_pd","Compares packed double-precision (64-bit) floating-point elements in `a` and `b`, and returns packed minimum values"],["_mm256_min_ps","Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and returns packed minimum values"],["_mm256_movedup_pd","Duplicate even-indexed double-precision (64-bit) floating-point elements from `a`, and returns the results."],["_mm256_movehdup_ps","Duplicate odd-indexed single-precision (32-bit) floating-point elements from `a`, and returns the results."],["_mm256_moveldup_ps","Duplicate even-indexed single-precision (32-bit) floating-point elements from `a`, and returns the results."],["_mm256_movemask_epi8","Creates mask from the most significant bit of each 8-bit element in `a`, return the result."],["_mm256_movemask_pd","Sets each bit of the returned mask based on the most significant bit of the corresponding packed double-precision (64-bit) floating-point element in `a`."],["_mm256_movemask_ps","Sets each bit of the returned mask based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in `a`."],["_mm256_mpsadbw_epu8","Computes the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in `a` compared to those in `b`, and stores the 16-bit results in dst. Eight SADs are performed for each 128-bit lane using one quadruplet from `b` and eight quadruplets from `a`. One quadruplet is selected from `b` starting at on the offset specified in `imm8`. Eight quadruplets are formed from sequential 8-bit integers selected from `a` starting at the offset specified in `imm8`."],["_mm256_mul_epi32","Multiplies the low 32-bit integers from each packed 64-bit element in `a` and `b`"],["_mm256_mul_epu32","Multiplies the low unsigned 32-bit integers from each packed 64-bit element in `a` and `b`"],["_mm256_mul_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm256_mul_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`."],["_mm256_mulhi_epi16","Multiplies the packed 16-bit integers in `a` and `b`, producing intermediate 32-bit integers and returning the high 16 bits of the intermediate integers."],["_mm256_mulhi_epu16","Multiplies the packed unsigned 16-bit integers in `a` and `b`, producing intermediate 32-bit integers and returning the high 16 bits of the intermediate integers."],["_mm256_mulhrs_epi16","Multiplies packed 16-bit integers in `a` and `b`, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and return bits `[16:1]`."],["_mm256_mullo_epi16","Multiplies the packed 16-bit integers in `a` and `b`, producing intermediate 32-bit integers, and returns the low 16 bits of the intermediate integers"],["_mm256_mullo_epi32","Multiplies the packed 32-bit integers in `a` and `b`, producing intermediate 64-bit integers, and returns the low 32 bits of the intermediate integers"],["_mm256_or_pd","Computes the bitwise OR packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm256_or_ps","Computes the bitwise OR packed single-precision (32-bit) floating-point elements in `a` and `b`."],["_mm256_or_si256","Computes the bitwise OR of 256 bits (representing integer data) in `a` and `b`"],["_mm256_packs_epi16","Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers using signed saturation"],["_mm256_packs_epi32","Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers using signed saturation"],["_mm256_packus_epi16","Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers using unsigned saturation"],["_mm256_packus_epi32","Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers using unsigned saturation"],["_mm256_permute2f128_pd","Shuffles 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) selected by `imm8` from `a` and `b`."],["_mm256_permute2f128_ps","Shuffles 256 bits (composed of 8 packed single-precision (32-bit) floating-point elements) selected by `imm8` from `a` and `b`."],["_mm256_permute2f128_si256","Shuffles 258-bits (composed of integer data) selected by `imm8` from `a` and `b`."],["_mm256_permute2x128_si256","Shuffles 128-bits of integer data selected by `imm8` from `a` and `b`."],["_mm256_permute4x64_epi64","Permutes 64-bit integers from `a` using control mask `imm8`."],["_mm256_permute4x64_pd","Shuffles 64-bit floating-point elements in `a` across lanes using the control in `imm8`."],["_mm256_permute_pd","Shuffles double-precision (64-bit) floating-point elements in `a` within 128-bit lanes using the control in `imm8`."],["_mm256_permute_ps","Shuffles single-precision (32-bit) floating-point elements in `a` within 128-bit lanes using the control in `imm8`."],["_mm256_permutevar8x32_epi32","Permutes packed 32-bit integers from `a` according to the content of `b`."],["_mm256_permutevar8x32_ps","Shuffles eight 32-bit foating-point elements in `a` across lanes using the corresponding 32-bit integer index in `idx`."],["_mm256_permutevar_pd","Shuffles double-precision (64-bit) floating-point elements in `a` within 256-bit lanes using the control in `b`."],["_mm256_permutevar_ps","Shuffles single-precision (32-bit) floating-point elements in `a` within 128-bit lanes using the control in `b`."],["_mm256_rcp_ps","Computes the approximate reciprocal of packed single-precision (32-bit) floating-point elements in `a`, and returns the results. The maximum relative error for this approximation is less than 1.5*2^-12."],["_mm256_round_pd","Rounds packed double-precision (64-bit) floating point elements in `a` according to the flag `b`. The value of `b` may be as follows:"],["_mm256_round_ps","Rounds packed single-precision (32-bit) floating point elements in `a` according to the flag `b`. The value of `b` may be as follows:"],["_mm256_rsqrt_ps","Computes the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in `a`, and returns the results. The maximum relative error for this approximation is less than 1.5*2^-12."],["_mm256_sad_epu8","Computes the absolute differences of packed unsigned 8-bit integers in `a` and `b`, then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of the 64-bit return value"],["_mm256_set1_epi16","Broadcasts 16-bit integer `a` to all all elements of returned vector. This intrinsic may generate the `vpbroadcastw`."],["_mm256_set1_epi32","Broadcasts 32-bit integer `a` to all elements of returned vector. This intrinsic may generate the `vpbroadcastd`."],["_mm256_set1_epi64x","Broadcasts 64-bit integer `a` to all elements of returned vector. This intrinsic may generate the `vpbroadcastq`."],["_mm256_set1_epi8","Broadcasts 8-bit integer `a` to all elements of returned vector. This intrinsic may generate the `vpbroadcastb`."],["_mm256_set1_pd","Broadcasts double-precision (64-bit) floating-point value `a` to all elements of returned vector."],["_mm256_set1_ps","Broadcasts single-precision (32-bit) floating-point value `a` to all elements of returned vector."],["_mm256_set_epi16","Sets packed 16-bit integers in returned vector with the supplied values."],["_mm256_set_epi32","Sets packed 32-bit integers in returned vector with the supplied values."],["_mm256_set_epi64x","Sets packed 64-bit integers in returned vector with the supplied values."],["_mm256_set_epi8","Sets packed 8-bit integers in returned vector with the supplied values in reverse order."],["_mm256_set_m128","Sets packed __m256 returned vector with the supplied values."],["_mm256_set_m128d","Sets packed __m256d returned vector with the supplied values."],["_mm256_set_m128i","Sets packed __m256i returned vector with the supplied values."],["_mm256_set_pd","Sets packed double-precision (64-bit) floating-point elements in returned vector with the supplied values."],["_mm256_set_ps","Sets packed single-precision (32-bit) floating-point elements in returned vector with the supplied values."],["_mm256_setr_epi16","Sets packed 16-bit integers in returned vector with the supplied values in reverse order."],["_mm256_setr_epi32","Sets packed 32-bit integers in returned vector with the supplied values in reverse order."],["_mm256_setr_epi64x","Sets packed 64-bit integers in returned vector with the supplied values in reverse order."],["_mm256_setr_epi8","Sets packed 8-bit integers in returned vector with the supplied values in reverse order."],["_mm256_setr_m128","Sets packed __m256 returned vector with the supplied values."],["_mm256_setr_m128d","Sets packed __m256d returned vector with the supplied values."],["_mm256_setr_m128i","Sets packed __m256i returned vector with the supplied values."],["_mm256_setr_pd","Sets packed double-precision (64-bit) floating-point elements in returned vector with the supplied values in reverse order."],["_mm256_setr_ps","Sets packed single-precision (32-bit) floating-point elements in returned vector with the supplied values in reverse order."],["_mm256_setzero_pd","Returns vector of type __m256d with all elements set to zero."],["_mm256_setzero_ps","Returns vector of type __m256 with all elements set to zero."],["_mm256_setzero_si256","Returns vector of type __m256i with all elements set to zero."],["_mm256_shuffle_epi32","Shuffles 32-bit integers in 128-bit lanes of `a` using the control in `imm8`."],["_mm256_shuffle_epi8","Shuffles bytes from `a` according to the content of `b`."],["_mm256_shuffle_pd","Shuffles double-precision (64-bit) floating-point elements within 128-bit lanes using the control in `imm8`."],["_mm256_shuffle_ps","Shuffles single-precision (32-bit) floating-point elements in `a` within 128-bit lanes using the control in `imm8`."],["_mm256_shufflehi_epi16","Shuffles 16-bit integers in the high 64 bits of 128-bit lanes of `a` using the control in `imm8`. The low 64 bits of 128-bit lanes of `a` are copied to the output."],["_mm256_shufflelo_epi16","Shuffles 16-bit integers in the low 64 bits of 128-bit lanes of `a` using the control in `imm8`. The high 64 bits of 128-bit lanes of `a` are copied to the output."],["_mm256_sign_epi16","Negates packed 16-bit integers in `a` when the corresponding signed 16-bit integer in `b` is negative, and returns the results. Results are zeroed out when the corresponding element in `b` is zero."],["_mm256_sign_epi32","Negates packed 32-bit integers in `a` when the corresponding signed 32-bit integer in `b` is negative, and returns the results. Results are zeroed out when the corresponding element in `b` is zero."],["_mm256_sign_epi8","Negates packed 8-bit integers in `a` when the corresponding signed 8-bit integer in `b` is negative, and returns the results. Results are zeroed out when the corresponding element in `b` is zero."],["_mm256_sll_epi16","Shifts packed 16-bit integers in `a` left by `count` while shifting in zeros, and returns the result"],["_mm256_sll_epi32","Shifts packed 32-bit integers in `a` left by `count` while shifting in zeros, and returns the result"],["_mm256_sll_epi64","Shifts packed 64-bit integers in `a` left by `count` while shifting in zeros, and returns the result"],["_mm256_slli_epi16","Shifts packed 16-bit integers in `a` left by `imm8` while shifting in zeros, return the results;"],["_mm256_slli_epi32","Shifts packed 32-bit integers in `a` left by `imm8` while shifting in zeros, return the results;"],["_mm256_slli_epi64","Shifts packed 64-bit integers in `a` left by `imm8` while shifting in zeros, return the results;"],["_mm256_slli_si256","Shifts 128-bit lanes in `a` left by `imm8` bytes while shifting in zeros."],["_mm256_sllv_epi32","Shifts packed 32-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and returns the result."],["_mm256_sllv_epi64","Shifts packed 64-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and returns the result."],["_mm256_sqrt_pd","Returns the square root of packed double-precision (64-bit) floating point elements in `a`."],["_mm256_sqrt_ps","Returns the square root of packed single-precision (32-bit) floating point elements in `a`."],["_mm256_sra_epi16","Shifts packed 16-bit integers in `a` right by `count` while shifting in sign bits."],["_mm256_sra_epi32","Shifts packed 32-bit integers in `a` right by `count` while shifting in sign bits."],["_mm256_srai_epi16","Shifts packed 16-bit integers in `a` right by `imm8` while shifting in sign bits."],["_mm256_srai_epi32","Shifts packed 32-bit integers in `a` right by `imm8` while shifting in sign bits."],["_mm256_srav_epi32","Shifts packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in sign bits."],["_mm256_srl_epi16","Shifts packed 16-bit integers in `a` right by `count` while shifting in zeros."],["_mm256_srl_epi32","Shifts packed 32-bit integers in `a` right by `count` while shifting in zeros."],["_mm256_srl_epi64","Shifts packed 64-bit integers in `a` right by `count` while shifting in zeros."],["_mm256_srli_epi16","Shifts packed 16-bit integers in `a` right by `imm8` while shifting in zeros"],["_mm256_srli_epi32","Shifts packed 32-bit integers in `a` right by `imm8` while shifting in zeros"],["_mm256_srli_epi64","Shifts packed 64-bit integers in `a` right by `imm8` while shifting in zeros"],["_mm256_srli_si256","Shifts 128-bit lanes in `a` right by `imm8` bytes while shifting in zeros."],["_mm256_srlv_epi32","Shifts packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,"],["_mm256_srlv_epi64","Shifts packed 64-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,"],["_mm256_store_pd","Stores 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from `a` into memory. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated."],["_mm256_store_ps","Stores 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from `a` into memory. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated."],["_mm256_store_si256","Stores 256-bits of integer data from `a` into memory. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated."],["_mm256_storeu2_m128","Stores the high and low 128-bit halves (each composed of 4 packed single-precision (32-bit) floating-point elements) from `a` into memory two different 128-bit locations. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary."],["_mm256_storeu2_m128d","Stores the high and low 128-bit halves (each composed of 2 packed double-precision (64-bit) floating-point elements) from `a` into memory two different 128-bit locations. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary."],["_mm256_storeu2_m128i","Stores the high and low 128-bit halves (each composed of integer data) from `a` into memory two different 128-bit locations. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary."],["_mm256_storeu_pd","Stores 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from `a` into memory. `mem_addr` does not need to be aligned on any particular boundary."],["_mm256_storeu_ps","Stores 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from `a` into memory. `mem_addr` does not need to be aligned on any particular boundary."],["_mm256_storeu_si256","Stores 256-bits of integer data from `a` into memory. \t`mem_addr` does not need to be aligned on any particular boundary."],["_mm256_stream_pd","Moves double-precision values from a 256-bit vector of `[4 x double]` to a 32-byte aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)."],["_mm256_stream_ps","Moves single-precision floating point values from a 256-bit vector of `[8 x float]` to a 32-byte aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)."],["_mm256_stream_si256","Moves integer data from a 256-bit integer vector to a 32-byte aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)"],["_mm256_sub_epi16","Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`"],["_mm256_sub_epi32","Subtract packed 32-bit integers in `b` from packed 16-bit integers in `a`"],["_mm256_sub_epi64","Subtract packed 64-bit integers in `b` from packed 16-bit integers in `a`"],["_mm256_sub_epi8","Subtract packed 8-bit integers in `b` from packed 16-bit integers in `a`"],["_mm256_sub_pd","Subtracts packed double-precision (64-bit) floating-point elements in `b` from packed elements in `a`."],["_mm256_sub_ps","Subtracts packed single-precision (32-bit) floating-point elements in `b` from packed elements in `a`."],["_mm256_subs_epi16","Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a` using saturation."],["_mm256_subs_epi8","Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a` using saturation."],["_mm256_subs_epu16","Subtract packed unsigned 16-bit integers in `b` from packed 16-bit integers in `a` using saturation."],["_mm256_subs_epu8","Subtract packed unsigned 8-bit integers in `b` from packed 8-bit integers in `a` using saturation."],["_mm256_testc_pd","Computes the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `CF` value."],["_mm256_testc_ps","Computes the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `CF` value."],["_mm256_testc_si256","Computes the bitwise AND of 256 bits (representing integer data) in `a` and `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0. Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if the result is zero, otherwise set `CF` to 0. Return the `CF` value."],["_mm256_testnzc_pd","Computes the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0."],["_mm256_testnzc_ps","Computes the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0."],["_mm256_testnzc_si256","Computes the bitwise AND of 256 bits (representing integer data) in `a` and `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0. Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if the result is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0."],["_mm256_testz_pd","Computes the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `ZF` value."],["_mm256_testz_ps","Computes the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `ZF` value."],["_mm256_testz_si256","Computes the bitwise AND of 256 bits (representing integer data) in `a` and `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0. Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if the result is zero, otherwise set `CF` to 0. Return the `ZF` value."],["_mm256_undefined_pd","Returns vector of type `__m256d` with undefined elements."],["_mm256_undefined_ps","Returns vector of type `__m256` with undefined elements."],["_mm256_undefined_si256","Returns vector of type __m256i with undefined elements."],["_mm256_unpackhi_epi16","Unpacks and interleave 16-bit integers from the high half of each 128-bit lane of `a` and `b`."],["_mm256_unpackhi_epi32","Unpacks and interleave 32-bit integers from the high half of each 128-bit lane of `a` and `b`."],["_mm256_unpackhi_epi64","Unpacks and interleave 64-bit integers from the high half of each 128-bit lane of `a` and `b`."],["_mm256_unpackhi_epi8","Unpacks and interleave 8-bit integers from the high half of each 128-bit lane in `a` and `b`."],["_mm256_unpackhi_pd","Unpacks and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in `a` and `b`."],["_mm256_unpackhi_ps","Unpacks and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in `a` and `b`."],["_mm256_unpacklo_epi16","Unpacks and interleave 16-bit integers from the low half of each 128-bit lane of `a` and `b`."],["_mm256_unpacklo_epi32","Unpacks and interleave 32-bit integers from the low half of each 128-bit lane of `a` and `b`."],["_mm256_unpacklo_epi64","Unpacks and interleave 64-bit integers from the low half of each 128-bit lane of `a` and `b`."],["_mm256_unpacklo_epi8","Unpacks and interleave 8-bit integers from the low half of each 128-bit lane of `a` and `b`."],["_mm256_unpacklo_pd","Unpacks and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in `a` and `b`."],["_mm256_unpacklo_ps","Unpacks and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in `a` and `b`."],["_mm256_xor_pd","Computes the bitwise XOR of packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm256_xor_ps","Computes the bitwise XOR of packed single-precision (32-bit) floating-point elements in `a` and `b`."],["_mm256_xor_si256","Computes the bitwise XOR of 256 bits (representing integer data) in `a` and `b`"],["_mm256_zeroall","Zeroes the contents of all XMM or YMM registers."],["_mm256_zeroupper","Zeroes the upper 128 bits of all YMM registers; the lower 128-bits of the registers are unmodified."],["_mm256_zextpd128_pd256","Constructs a 256-bit floating-point vector of `[4 x double]` from a 128-bit floating-point vector of `[2 x double]`. The lower 128 bits contain the value of the source vector. The upper 128 bits are set to zero."],["_mm256_zextps128_ps256","Constructs a 256-bit floating-point vector of `[8 x float]` from a 128-bit floating-point vector of `[4 x float]`. The lower 128 bits contain the value of the source vector. The upper 128 bits are set to zero."],["_mm256_zextsi128_si256","Constructs a 256-bit integer vector from a 128-bit integer vector. The lower 128 bits contain the value of the source vector. The upper 128 bits are set to zero."],["_mm512_abs_epi32","Computes the absolute values of packed 32-bit integers in `a`."],["_mm512_madd52hi_epu64","Multiply packed unsigned 52-bit integers in each 64-bit element of `b` and `c` to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`."],["_mm512_madd52lo_epu64","Multiply packed unsigned 52-bit integers in each 64-bit element of `b` and `c` to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`."],["_mm512_mask_abs_epi32","Computes the absolute value of packed 32-bit integers in `a`, and store the unsigned results in `dst` using writemask `k` (elements are copied from `src` when the corresponding mask bit is not set)."],["_mm512_maskz_abs_epi32","Computes the absolute value of packed 32-bit integers in `a`, and store the unsigned results in `dst` using zeromask `k` (elements are zeroed out when the corresponding mask bit is not set)."],["_mm512_set1_epi64","Broadcast 64-bit integer `a` to all elements of `dst`."],["_mm512_setr_epi32","Sets packed 32-bit integers in `dst` with the supplied values in reverse order."],["_mm512_setzero_si512","Returns vector of type `__m512i` with all elements set to zero."],["_mm_abs_epi16","Computes the absolute value of each of the packed 16-bit signed integers in `a` and return the 16-bit unsigned integer"],["_mm_abs_epi32","Computes the absolute value of each of the packed 32-bit signed integers in `a` and return the 32-bit unsigned integer"],["_mm_abs_epi8","Computes the absolute value of packed 8-bit signed integers in `a` and return the unsigned results."],["_mm_abs_pi16","Computes the absolute value of packed 8-bit integers in `a`, and returns the unsigned results."],["_mm_abs_pi32","Computes the absolute value of packed 32-bit integers in `a`, and returns the unsigned results."],["_mm_abs_pi8","Computes the absolute value of packed 8-bit integers in `a` and return the unsigned results."],["_mm_add_epi16","Adds packed 16-bit integers in `a` and `b`."],["_mm_add_epi32","Adds packed 32-bit integers in `a` and `b`."],["_mm_add_epi64","Adds packed 64-bit integers in `a` and `b`."],["_mm_add_epi8","Adds packed 8-bit integers in `a` and `b`."],["_mm_add_pd","Adds packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm_add_pi16","Adds packed 16-bit integers in `a` and `b`."],["_mm_add_pi32","Adds packed 32-bit integers in `a` and `b`."],["_mm_add_pi8","Adds packed 8-bit integers in `a` and `b`."],["_mm_add_ps","Adds __m128 vectors."],["_mm_add_sd","Returns a new vector with the low element of `a` replaced by the sum of the low elements of `a` and `b`."],["_mm_add_si64","Adds two signed or unsigned 64-bit integer values, returning the lower 64 bits of the sum."],["_mm_add_ss","Adds the first component of `a` and `b`, the other components are copied from `a`."],["_mm_adds_epi16","Adds packed 16-bit integers in `a` and `b` using saturation."],["_mm_adds_epi8","Adds packed 8-bit integers in `a` and `b` using saturation."],["_mm_adds_epu16","Adds packed unsigned 16-bit integers in `a` and `b` using saturation."],["_mm_adds_epu8","Adds packed unsigned 8-bit integers in `a` and `b` using saturation."],["_mm_adds_pi16","Adds packed 16-bit integers in `a` and `b` using saturation."],["_mm_adds_pi8","Adds packed 8-bit integers in `a` and `b` using saturation."],["_mm_adds_pu16","Adds packed unsigned 16-bit integers in `a` and `b` using saturation."],["_mm_adds_pu8","Adds packed unsigned 8-bit integers in `a` and `b` using saturation."],["_mm_addsub_pd","Alternatively add and subtract packed double-precision (64-bit) floating-point elements in `a` to/from packed elements in `b`."],["_mm_addsub_ps","Alternatively add and subtract packed single-precision (32-bit) floating-point elements in `a` to/from packed elements in `b`."],["_mm_aesdec_si128","Performs one round of an AES decryption flow on data (state) in `a`."],["_mm_aesdeclast_si128","Performs the last round of an AES decryption flow on data (state) in `a`."],["_mm_aesenc_si128","Performs one round of an AES encryption flow on data (state) in `a`."],["_mm_aesenclast_si128","Performs the last round of an AES encryption flow on data (state) in `a`."],["_mm_aesimc_si128","Performs the `InvMixColumns` transformation on `a`."],["_mm_aeskeygenassist_si128","Assist in expanding the AES cipher key."],["_mm_alignr_epi8","Concatenate 16-byte blocks in `a` and `b` into a 32-byte temporary result, shift the result right by `n` bytes, and returns the low 16 bytes."],["_mm_alignr_pi8","Concatenates the two 64-bit integer vector operands, and right-shifts the result by the number of bytes specified in the immediate operand."],["_mm_and_pd","Computes the bitwise AND of packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm_and_ps","Bitwise AND of packed single-precision (32-bit) floating-point elements."],["_mm_and_si128","Computes the bitwise AND of 128 bits (representing integer data) in `a` and `b`."],["_mm_andnot_pd","Computes the bitwise NOT of `a` and then AND with `b`."],["_mm_andnot_ps","Bitwise AND-NOT of packed single-precision (32-bit) floating-point elements."],["_mm_andnot_si128","Computes the bitwise NOT of 128 bits (representing integer data) in `a` and then AND with `b`."],["_mm_avg_epu16","Averages packed unsigned 16-bit integers in `a` and `b`."],["_mm_avg_epu8","Averages packed unsigned 8-bit integers in `a` and `b`."],["_mm_avg_pu16","Computes the rounded averages of the packed unsigned 16-bit integer values and writes the averages to the corresponding bits in the destination."],["_mm_avg_pu8","Computes the rounded averages of the packed unsigned 8-bit integer values and writes the averages to the corresponding bits in the destination."],["_mm_blend_epi16","Blend packed 16-bit integers from `a` and `b` using the mask `imm8`."],["_mm_blend_epi32","Blends packed 32-bit integers from `a` and `b` using control mask `imm8`."],["_mm_blend_pd","Blend packed double-precision (64-bit) floating-point elements from `a` and `b` using control mask `imm2`"],["_mm_blend_ps","Blend packed single-precision (32-bit) floating-point elements from `a` and `b` using mask `imm4`"],["_mm_blendv_epi8","Blend packed 8-bit integers from `a` and `b` using `mask`"],["_mm_blendv_pd","Blend packed double-precision (64-bit) floating-point elements from `a` and `b` using `mask`"],["_mm_blendv_ps","Blend packed single-precision (32-bit) floating-point elements from `a` and `b` using `mask`"],["_mm_broadcast_ss","Broadcasts a single-precision (32-bit) floating-point element from memory to all elements of the returned vector."],["_mm_broadcastb_epi8","Broadcasts the low packed 8-bit integer from `a` to all elements of the 128-bit returned value."],["_mm_broadcastd_epi32","Broadcasts the low packed 32-bit integer from `a` to all elements of the 128-bit returned value."],["_mm_broadcastq_epi64","Broadcasts the low packed 64-bit integer from `a` to all elements of the 128-bit returned value."],["_mm_broadcastsd_pd","Broadcasts the low double-precision (64-bit) floating-point element from `a` to all elements of the 128-bit returned value."],["_mm_broadcastss_ps","Broadcasts the low single-precision (32-bit) floating-point element from `a` to all elements of the 128-bit returned value."],["_mm_broadcastw_epi16","Broadcasts the low packed 16-bit integer from a to all elements of the 128-bit returned value"],["_mm_bslli_si128","Shifts `a` left by `imm8` bytes while shifting in zeros."],["_mm_bsrli_si128","Shifts `a` right by `imm8` bytes while shifting in zeros."],["_mm_castpd_ps","Casts a 128-bit floating-point vector of `[2 x double]` into a 128-bit floating-point vector of `[4 x float]`."],["_mm_castpd_si128","Casts a 128-bit floating-point vector of `[2 x double]` into a 128-bit integer vector."],["_mm_castps_pd","Casts a 128-bit floating-point vector of `[4 x float]` into a 128-bit floating-point vector of `[2 x double]`."],["_mm_castps_si128","Casts a 128-bit floating-point vector of `[4 x float]` into a 128-bit integer vector."],["_mm_castsi128_pd","Casts a 128-bit integer vector into a 128-bit floating-point vector of `[2 x double]`."],["_mm_castsi128_ps","Casts a 128-bit integer vector into a 128-bit floating-point vector of `[4 x float]`."],["_mm_ceil_pd","Round the packed double-precision (64-bit) floating-point elements in `a` up to an integer value, and stores the results as packed double-precision floating-point elements."],["_mm_ceil_ps","Round the packed single-precision (32-bit) floating-point elements in `a` up to an integer value, and stores the results as packed single-precision floating-point elements."],["_mm_ceil_sd","Round the lower double-precision (64-bit) floating-point element in `b` up to an integer value, store the result as a double-precision floating-point element in the lower element of the intrisic result, and copies the upper element from `a` to the upper element of the intrinsic result."],["_mm_ceil_ss","Round the lower single-precision (32-bit) floating-point element in `b` up to an integer value, store the result as a single-precision floating-point element in the lower element of the intrinsic result, and copies the upper 3 packed elements from `a` to the upper elements of the intrinsic result."],["_mm_clflush","Invalidates and flushes the cache line that contains `p` from all levels of the cache hierarchy."],["_mm_clmulepi64_si128","Performs a carry-less multiplication of two 64-bit polynomials over the finite field GF(2^k)."],["_mm_cmp_pd","Compares packed double-precision (64-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `imm8`."],["_mm_cmp_ps","Compares packed single-precision (32-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `imm8`."],["_mm_cmp_sd","Compares the lower double-precision (64-bit) floating-point element in `a` and `b` based on the comparison operand specified by `imm8`, store the result in the lower element of returned vector, and copies the upper element from `a` to the upper element of returned vector."],["_mm_cmp_ss","Compares the lower single-precision (32-bit) floating-point element in `a` and `b` based on the comparison operand specified by `imm8`, store the result in the lower element of returned vector, and copies the upper 3 packed elements from `a` to the upper elements of returned vector."],["_mm_cmpeq_epi16","Compares packed 16-bit integers in `a` and `b` for equality."],["_mm_cmpeq_epi32","Compares packed 32-bit integers in `a` and `b` for equality."],["_mm_cmpeq_epi64","Compares packed 64-bit integers in `a` and `b` for equality"],["_mm_cmpeq_epi8","Compares packed 8-bit integers in `a` and `b` for equality."],["_mm_cmpeq_pd","Compares corresponding elements in `a` and `b` for equality."],["_mm_cmpeq_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input elements were equal, or `0` otherwise."],["_mm_cmpeq_sd","Returns a new vector with the low element of `a` replaced by the equality comparison of the lower elements of `a` and `b`."],["_mm_cmpeq_ss","Compares the lowest `f32` of both inputs for equality. The lowest 32 bits of the result will be `0xffffffff` if the two inputs are equal, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpestra","Compares packed strings in `a` and `b` with lengths `la` and `lb` using the control in `imm8`, and return `1` if `b` did not contain a null character and the resulting mask was zero, and `0` otherwise."],["_mm_cmpestrc","Compares packed strings in `a` and `b` with lengths `la` and `lb` using the control in `imm8`, and return `1` if the resulting mask was non-zero, and `0` otherwise."],["_mm_cmpestri","Compares packed strings `a` and `b` with lengths `la` and `lb` using the control in `imm8` and return the generated index. Similar to [`_mm_cmpistri`] with the exception that [`_mm_cmpistri`] implicitly determines the length of `a` and `b`."],["_mm_cmpestrm","Compares packed strings in `a` and `b` with lengths `la` and `lb` using the control in `imm8`, and return the generated mask."],["_mm_cmpestro","Compares packed strings in `a` and `b` with lengths `la` and `lb` using the control in `imm8`, and return bit `0` of the resulting bit mask."],["_mm_cmpestrs","Compares packed strings in `a` and `b` with lengths `la` and `lb` using the control in `imm8`, and return `1` if any character in a was null, and `0` otherwise."],["_mm_cmpestrz","Compares packed strings in `a` and `b` with lengths `la` and `lb` using the control in `imm8`, and return `1` if any character in `b` was null, and `0` otherwise."],["_mm_cmpge_pd","Compares corresponding elements in `a` and `b` for greater-than-or-equal."],["_mm_cmpge_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is greater than or equal to the corresponding element in `b`, or `0` otherwise."],["_mm_cmpge_sd","Returns a new vector with the low element of `a` replaced by the greater-than-or-equal comparison of the lower elements of `a` and `b`."],["_mm_cmpge_ss","Compares the lowest `f32` of both inputs for greater than or equal. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is greater than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpgt_epi16","Compares packed 16-bit integers in `a` and `b` for greater-than."],["_mm_cmpgt_epi32","Compares packed 32-bit integers in `a` and `b` for greater-than."],["_mm_cmpgt_epi64","Compares packed 64-bit integers in `a` and `b` for greater-than, return the results."],["_mm_cmpgt_epi8","Compares packed 8-bit integers in `a` and `b` for greater-than."],["_mm_cmpgt_pd","Compares corresponding elements in `a` and `b` for greater-than."],["_mm_cmpgt_pi16","Compares whether each element of `a` is greater than the corresponding element of `b` returning `0` for `false` and `-1` for `true`."],["_mm_cmpgt_pi32","Compares whether each element of `a` is greater than the corresponding element of `b` returning `0` for `false` and `-1` for `true`."],["_mm_cmpgt_pi8","Compares whether each element of `a` is greater than the corresponding element of `b` returning `0` for `false` and `-1` for `true`."],["_mm_cmpgt_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is greater than the corresponding element in `b`, or `0` otherwise."],["_mm_cmpgt_sd","Returns a new vector with the low element of `a` replaced by the greater-than comparison of the lower elements of `a` and `b`."],["_mm_cmpgt_ss","Compares the lowest `f32` of both inputs for greater than. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is greater than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpistra","Compares packed strings with implicit lengths in `a` and `b` using the control in `imm8`, and return `1` if `b` did not contain a null character and the resulting mask was zero, and `0` otherwise."],["_mm_cmpistrc","Compares packed strings with implicit lengths in `a` and `b` using the control in `imm8`, and return `1` if the resulting mask was non-zero, and `0` otherwise."],["_mm_cmpistri","Compares packed strings with implicit lengths in `a` and `b` using the control in `imm8` and return the generated index. Similar to [`_mm_cmpestri`] with the exception that [`_mm_cmpestri`] requires the lengths of `a` and `b` to be explicitly specified."],["_mm_cmpistrm","Compares packed strings with implicit lengths in `a` and `b` using the control in `imm8`, and return the generated mask."],["_mm_cmpistro","Compares packed strings with implicit lengths in `a` and `b` using the control in `imm8`, and return bit `0` of the resulting bit mask."],["_mm_cmpistrs","Compares packed strings with implicit lengths in `a` and `b` using the control in `imm8`, and returns `1` if any character in `a` was null, and `0` otherwise."],["_mm_cmpistrz","Compares packed strings with implicit lengths in `a` and `b` using the control in `imm8`, and return `1` if any character in `b` was null. and `0` otherwise."],["_mm_cmple_pd","Compares corresponding elements in `a` and `b` for less-than-or-equal"],["_mm_cmple_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is less than or equal to the corresponding element in `b`, or `0` otherwise."],["_mm_cmple_sd","Returns a new vector with the low element of `a` replaced by the less-than-or-equal comparison of the lower elements of `a` and `b`."],["_mm_cmple_ss","Compares the lowest `f32` of both inputs for less than or equal. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is less than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmplt_epi16","Compares packed 16-bit integers in `a` and `b` for less-than."],["_mm_cmplt_epi32","Compares packed 32-bit integers in `a` and `b` for less-than."],["_mm_cmplt_epi8","Compares packed 8-bit integers in `a` and `b` for less-than."],["_mm_cmplt_pd","Compares corresponding elements in `a` and `b` for less-than."],["_mm_cmplt_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is less than the corresponding element in `b`, or `0` otherwise."],["_mm_cmplt_sd","Returns a new vector with the low element of `a` replaced by the less-than comparison of the lower elements of `a` and `b`."],["_mm_cmplt_ss","Compares the lowest `f32` of both inputs for less than. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is less than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpneq_pd","Compares corresponding elements in `a` and `b` for not-equal."],["_mm_cmpneq_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input elements are not equal, or `0` otherwise."],["_mm_cmpneq_sd","Returns a new vector with the low element of `a` replaced by the not-equal comparison of the lower elements of `a` and `b`."],["_mm_cmpneq_ss","Compares the lowest `f32` of both inputs for inequality. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not equal to `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpnge_pd","Compares corresponding elements in `a` and `b` for not-greater-than-or-equal."],["_mm_cmpnge_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is not greater than or equal to the corresponding element in `b`, or `0` otherwise."],["_mm_cmpnge_sd","Returns a new vector with the low element of `a` replaced by the not-greater-than-or-equal comparison of the lower elements of `a` and `b`."],["_mm_cmpnge_ss","Compares the lowest `f32` of both inputs for not-greater-than-or-equal. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not greater than or equal to `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpngt_pd","Compares corresponding elements in `a` and `b` for not-greater-than."],["_mm_cmpngt_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is not greater than the corresponding element in `b`, or `0` otherwise."],["_mm_cmpngt_sd","Returns a new vector with the low element of `a` replaced by the not-greater-than comparison of the lower elements of `a` and `b`."],["_mm_cmpngt_ss","Compares the lowest `f32` of both inputs for not-greater-than. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not greater than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpnle_pd","Compares corresponding elements in `a` and `b` for not-less-than-or-equal."],["_mm_cmpnle_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is not less than or equal to the corresponding element in `b`, or `0` otherwise."],["_mm_cmpnle_sd","Returns a new vector with the low element of `a` replaced by the not-less-than-or-equal comparison of the lower elements of `a` and `b`."],["_mm_cmpnle_ss","Compares the lowest `f32` of both inputs for not-less-than-or-equal. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not less than or equal to `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpnlt_pd","Compares corresponding elements in `a` and `b` for not-less-than."],["_mm_cmpnlt_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is not less than the corresponding element in `b`, or `0` otherwise."],["_mm_cmpnlt_sd","Returns a new vector with the low element of `a` replaced by the not-less-than comparison of the lower elements of `a` and `b`."],["_mm_cmpnlt_ss","Compares the lowest `f32` of both inputs for not-less-than. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not less than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpord_pd","Compares corresponding elements in `a` and `b` to see if neither is `NaN`."],["_mm_cmpord_ps","Compares each of the four floats in `a` to the corresponding element in `b`. Returns four floats that have one of two possible bit patterns. The element in the output vector will be `0xffffffff` if the input elements in `a` and `b` are ordered (i.e., neither of them is a NaN), or 0 otherwise."],["_mm_cmpord_sd","Returns a new vector with the low element of `a` replaced by the result of comparing both of the lower elements of `a` and `b` to `NaN`. If neither are equal to `NaN` then `0xFFFFFFFFFFFFFFFF` is used and `0` otherwise."],["_mm_cmpord_ss","Checks if the lowest `f32` of both inputs are ordered. The lowest 32 bits of the result will be `0xffffffff` if neither of `a.extract(0)` or `b.extract(0)` is a NaN, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpunord_pd","Compares corresponding elements in `a` and `b` to see if either is `NaN`."],["_mm_cmpunord_ps","Compares each of the four floats in `a` to the corresponding element in `b`. Returns four floats that have one of two possible bit patterns. The element in the output vector will be `0xffffffff` if the input elements in `a` and `b` are unordered (i.e., at least on of them is a NaN), or 0 otherwise."],["_mm_cmpunord_sd","Returns a new vector with the low element of `a` replaced by the result of comparing both of the lower elements of `a` and `b` to `NaN`. If either is equal to `NaN` then `0xFFFFFFFFFFFFFFFF` is used and `0` otherwise."],["_mm_cmpunord_ss","Checks if the lowest `f32` of both inputs are unordered. The lowest 32 bits of the result will be `0xffffffff` if any of `a.extract(0)` or `b.extract(0)` is a NaN, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_comieq_sd","Compares the lower element of `a` and `b` for equality."],["_mm_comieq_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if they are equal, or `0` otherwise."],["_mm_comige_sd","Compares the lower element of `a` and `b` for greater-than-or-equal."],["_mm_comige_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is greater than or equal to the one from `b`, or `0` otherwise."],["_mm_comigt_sd","Compares the lower element of `a` and `b` for greater-than."],["_mm_comigt_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is greater than the one from `b`, or `0` otherwise."],["_mm_comile_sd","Compares the lower element of `a` and `b` for less-than-or-equal."],["_mm_comile_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is less than or equal to the one from `b`, or `0` otherwise."],["_mm_comilt_sd","Compares the lower element of `a` and `b` for less-than."],["_mm_comilt_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is less than the one from `b`, or `0` otherwise."],["_mm_comineq_sd","Compares the lower element of `a` and `b` for not-equal."],["_mm_comineq_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if they are not equal, or `0` otherwise."],["_mm_crc32_u16","Starting with the initial value in `crc`, return the accumulated CRC32 value for unsigned 16-bit integer `v`."],["_mm_crc32_u32","Starting with the initial value in `crc`, return the accumulated CRC32 value for unsigned 32-bit integer `v`."],["_mm_crc32_u64","Starting with the initial value in `crc`, return the accumulated CRC32 value for unsigned 64-bit integer `v`."],["_mm_crc32_u8","Starting with the initial value in `crc`, return the accumulated CRC32 value for unsigned 8-bit integer `v`."],["_mm_cvt_pi2ps","Converts two elements of a 64-bit vector of `[2 x i32]` into two floating point values and writes them to the lower 64-bits of the destination. The remaining higher order elements of the destination are copied from the corresponding elements in the first operand."],["_mm_cvt_ps2pi","Converts the two lower packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers."],["_mm_cvt_si2ss","Alias for `_mm_cvtsi32_ss`."],["_mm_cvt_ss2si","Alias for `_mm_cvtss_si32`."],["_mm_cvtepi16_epi32","Sign extend packed 16-bit integers in `a` to packed 32-bit integers"],["_mm_cvtepi16_epi64","Sign extend packed 16-bit integers in `a` to packed 64-bit integers"],["_mm_cvtepi32_epi64","Sign extend packed 32-bit integers in `a` to packed 64-bit integers"],["_mm_cvtepi32_pd","Converts the lower two packed 32-bit integers in `a` to packed double-precision (64-bit) floating-point elements."],["_mm_cvtepi32_ps","Converts packed 32-bit integers in `a` to packed single-precision (32-bit) floating-point elements."],["_mm_cvtepi8_epi16","Sign extend packed 8-bit integers in `a` to packed 16-bit integers"],["_mm_cvtepi8_epi32","Sign extend packed 8-bit integers in `a` to packed 32-bit integers"],["_mm_cvtepi8_epi64","Sign extend packed 8-bit integers in the low 8 bytes of `a` to packed 64-bit integers"],["_mm_cvtepu16_epi32","Zeroes extend packed unsigned 16-bit integers in `a` to packed 32-bit integers"],["_mm_cvtepu16_epi64","Zeroes extend packed unsigned 16-bit integers in `a` to packed 64-bit integers"],["_mm_cvtepu32_epi64","Zeroes extend packed unsigned 32-bit integers in `a` to packed 64-bit integers"],["_mm_cvtepu8_epi16","Zeroes extend packed unsigned 8-bit integers in `a` to packed 16-bit integers"],["_mm_cvtepu8_epi32","Zeroes extend packed unsigned 8-bit integers in `a` to packed 32-bit integers"],["_mm_cvtepu8_epi64","Zeroes extend packed unsigned 8-bit integers in `a` to packed 64-bit integers"],["_mm_cvtpd_epi32","Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers."],["_mm_cvtpd_pi32","Converts the two double-precision floating-point elements of a 128-bit vector of `[2 x double]` into two signed 32-bit integer values, returned in a 64-bit vector of `[2 x i32]`."],["_mm_cvtpd_ps","Converts packed double-precision (64-bit) floating-point elements in `a` to packed single-precision (32-bit) floating-point elements"],["_mm_cvtph_ps","Converts the 4 x 16-bit half-precision float values in the lowest 64-bit of the 128-bit vector `a` into 4 x 32-bit float values stored in a 128-bit wide vector."],["_mm_cvtpi16_ps","Converts a 64-bit vector of `i16`s into a 128-bit vector of 4 `f32`s."],["_mm_cvtpi32_pd","Converts the two signed 32-bit integer elements of a 64-bit vector of `[2 x i32]` into two double-precision floating-point values, returned in a 128-bit vector of `[2 x double]`."],["_mm_cvtpi32_ps","Converts two elements of a 64-bit vector of `[2 x i32]` into two floating point values and writes them to the lower 64-bits of the destination. The remaining higher order elements of the destination are copied from the corresponding elements in the first operand."],["_mm_cvtpi32x2_ps","Converts the two 32-bit signed integer values from each 64-bit vector operand of `[2 x i32]` into a 128-bit vector of `[4 x float]`."],["_mm_cvtpi8_ps","Converts the lower 4 8-bit values of `a` into a 128-bit vector of 4 `f32`s."],["_mm_cvtps_epi32","Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers."],["_mm_cvtps_pd","Converts packed single-precision (32-bit) floating-point elements in `a` to packed double-precision (64-bit) floating-point elements."],["_mm_cvtps_ph","Converts the 4 x 32-bit float values in the 128-bit vector `a` into 4 x 16-bit half-precision float values stored in the lowest 64-bit of a 128-bit vector."],["_mm_cvtps_pi16","Converts packed single-precision (32-bit) floating-point elements in `a` to packed 16-bit integers."],["_mm_cvtps_pi32","Converts the two lower packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers."],["_mm_cvtps_pi8","Converts packed single-precision (32-bit) floating-point elements in `a` to packed 8-bit integers, and returns theem in the lower 4 elements of the result."],["_mm_cvtpu16_ps","Converts a 64-bit vector of `i16`s into a 128-bit vector of 4 `f32`s."],["_mm_cvtpu8_ps","Converts the lower 4 8-bit values of `a` into a 128-bit vector of 4 `f32`s."],["_mm_cvtsd_f64","Returns the lower double-precision (64-bit) floating-point element of `a`."],["_mm_cvtsd_si32","Converts the lower double-precision (64-bit) floating-point element in a to a 32-bit integer."],["_mm_cvtsd_si64","Converts the lower double-precision (64-bit) floating-point element in a to a 64-bit integer."],["_mm_cvtsd_si64x","Alias for `_mm_cvtsd_si64`"],["_mm_cvtsd_ss","Converts the lower double-precision (64-bit) floating-point element in `b` to a single-precision (32-bit) floating-point element, store the result in the lower element of the return value, and copies the upper element from `a` to the upper element the return value."],["_mm_cvtsi128_si32","Returns the lowest element of `a`."],["_mm_cvtsi128_si64","Returns the lowest element of `a`."],["_mm_cvtsi128_si64x","Returns the lowest element of `a`."],["_mm_cvtsi32_sd","Returns `a` with its lower element replaced by `b` after converting it to an `f64`."],["_mm_cvtsi32_si128","Returns a vector whose lowest element is `a` and all higher elements are `0`."],["_mm_cvtsi32_si64","Copies 32-bit integer `a` to the lower elements of the return value, and zero the upper element of the return value."],["_mm_cvtsi32_ss","Converts a 32 bit integer to a 32 bit float. The result vector is the input vector `a` with the lowest 32 bit float replaced by the converted integer."],["_mm_cvtsi64_sd","Returns `a` with its lower element replaced by `b` after converting it to an `f64`."],["_mm_cvtsi64_si128","Returns a vector whose lowest element is `a` and all higher elements are `0`."],["_mm_cvtsi64_si32","Return the lower 32-bit integer in `a`."],["_mm_cvtsi64_ss","Converts a 64 bit integer to a 32 bit float. The result vector is the input vector `a` with the lowest 32 bit float replaced by the converted integer."],["_mm_cvtsi64x_sd","Returns `a` with its lower element replaced by `b` after converting it to an `f64`."],["_mm_cvtsi64x_si128","Returns a vector whose lowest element is `a` and all higher elements are `0`."],["_mm_cvtss_f32","Extracts the lowest 32 bit float from the input vector."],["_mm_cvtss_sd","Converts the lower single-precision (32-bit) floating-point element in `b` to a double-precision (64-bit) floating-point element, store the result in the lower element of the return value, and copies the upper element from `a` to the upper element the return value."],["_mm_cvtss_si32","Converts the lowest 32 bit float in the input vector to a 32 bit integer."],["_mm_cvtss_si64","Converts the lowest 32 bit float in the input vector to a 64 bit integer."],["_mm_cvtt_ps2pi","Converts the two lower packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers with truncation."],["_mm_cvtt_ss2si","Alias for `_mm_cvttss_si32`."],["_mm_cvttpd_epi32","Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers with truncation."],["_mm_cvttpd_pi32","Converts the two double-precision floating-point elements of a 128-bit vector of `[2 x double]` into two signed 32-bit integer values, returned in a 64-bit vector of `[2 x i32]`. If the result of either conversion is inexact, the result is truncated (rounded towards zero) regardless of the current MXCSR setting."],["_mm_cvttps_epi32","Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers with truncation."],["_mm_cvttps_pi32","Converts the two lower packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers with truncation."],["_mm_cvttsd_si32","Converts the lower double-precision (64-bit) floating-point element in `a` to a 32-bit integer with truncation."],["_mm_cvttsd_si64","Converts the lower double-precision (64-bit) floating-point element in `a` to a 64-bit integer with truncation."],["_mm_cvttsd_si64x","Alias for `_mm_cvttsd_si64`"],["_mm_cvttss_si32","Converts the lowest 32 bit float in the input vector to a 32 bit integer with truncation."],["_mm_cvttss_si64","Converts the lowest 32 bit float in the input vector to a 64 bit integer with truncation."],["_mm_div_pd","Divide packed double-precision (64-bit) floating-point elements in `a` by packed elements in `b`."],["_mm_div_ps","Divides __m128 vectors."],["_mm_div_sd","Returns a new vector with the low element of `a` replaced by the result of diving the lower element of `a` by the lower element of `b`."],["_mm_div_ss","Divides the first component of `b` by `a`, the other components are copied from `a`."],["_mm_dp_pd","Returns the dot product of two __m128d vectors."],["_mm_dp_ps","Returns the dot product of two __m128 vectors."],["_mm_empty","Empty the MMX state, which marks the x87 FPU registers as available for use by x87 instructions. This instruction must be used at the end of all MMX technology procedures."],["_mm_extract_epi16","Returns the `imm8` element of `a`."],["_mm_extract_epi32","Extracts an 32-bit integer from `a` selected with `imm8`"],["_mm_extract_epi64","Extracts an 64-bit integer from `a` selected with `imm8`"],["_mm_extract_epi8","Extracts an 8-bit integer from `a`, selected with `imm8`. Returns a 32-bit integer containing the zero-extended integer data."],["_mm_extract_pi16","Extracts 16-bit element from a 64-bit vector of `[4 x i16]` and returns it, as specified by the immediate integer operand."],["_mm_extract_ps","Extracts a single-precision (32-bit) floating-point element from `a`, selected with `imm8`"],["_mm_extract_si64","Extracts the bit range specified by `y` from the lower 64 bits of `x`."],["_mm_floor_pd","Round the packed double-precision (64-bit) floating-point elements in `a` down to an integer value, and stores the results as packed double-precision floating-point elements."],["_mm_floor_ps","Round the packed single-precision (32-bit) floating-point elements in `a` down to an integer value, and stores the results as packed single-precision floating-point elements."],["_mm_floor_sd","Round the lower double-precision (64-bit) floating-point element in `b` down to an integer value, store the result as a double-precision floating-point element in the lower element of the intrinsic result, and copies the upper element from `a` to the upper element of the intrinsic result."],["_mm_floor_ss","Round the lower single-precision (32-bit) floating-point element in `b` down to an integer value, store the result as a single-precision floating-point element in the lower element of the intrinsic result, and copies the upper 3 packed elements from `a` to the upper elements of the intrinsic result."],["_mm_fmadd_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and add the intermediate result to packed elements in `c`."],["_mm_fmadd_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and add the intermediate result to packed elements in `c`."],["_mm_fmadd_sd","Multiplies the lower double-precision (64-bit) floating-point elements in `a` and `b`, and add the intermediate result to the lower element in `c`. Stores the result in the lower element of the returned value, and copy the upper element from `a` to the upper elements of the result."],["_mm_fmadd_ss","Multiplies the lower single-precision (32-bit) floating-point elements in `a` and `b`, and add the intermediate result to the lower element in `c`. Stores the result in the lower element of the returned value, and copy the 3 upper elements from `a` to the upper elements of the result."],["_mm_fmaddsub_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and alternatively add and subtract packed elements in `c` to/from the intermediate result."],["_mm_fmaddsub_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and alternatively add and subtract packed elements in `c` to/from the intermediate result."],["_mm_fmsub_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the intermediate result."],["_mm_fmsub_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the intermediate result."],["_mm_fmsub_sd","Multiplies the lower double-precision (64-bit) floating-point elements in `a` and `b`, and subtract the lower element in `c` from the intermediate result. Store the result in the lower element of the returned value, and copy the upper element from `a` to the upper elements of the result."],["_mm_fmsub_ss","Multiplies the lower single-precision (32-bit) floating-point elements in `a` and `b`,  and subtract the lower element in `c` from the intermediate result. Store the result in the lower element of the returned value, and copy the 3 upper elements from `a` to the upper elements of the result."],["_mm_fmsubadd_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and alternatively subtract and add packed elements in `c` from/to the intermediate result."],["_mm_fmsubadd_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and alternatively subtract and add packed elements in `c` from/to the intermediate result."],["_mm_fnmadd_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to packed elements in `c`."],["_mm_fnmadd_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to packed elements in `c`."],["_mm_fnmadd_sd","Multiplies the lower double-precision (64-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to the lower element in `c`. Store the result in the lower element of the returned value, and copy the upper element from `a` to the upper elements of the result."],["_mm_fnmadd_ss","Multiplies the lower single-precision (32-bit) floating-point elements in `a` and `b`, and add the negated intermediate result to the lower element in `c`. Store the result in the lower element of the returned value, and copy the 3 upper elements from `a` to the upper elements of the result."],["_mm_fnmsub_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result."],["_mm_fnmsub_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result."],["_mm_fnmsub_sd","Multiplies the lower double-precision (64-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result. Store the result in the lower element of the returned value, and copy the upper element from `a` to the upper elements of the result."],["_mm_fnmsub_ss","Multiplies the lower single-precision (32-bit) floating-point elements in `a` and `b`, and subtract packed elements in `c` from the negated intermediate result. Store the result in the lower element of the returned value, and copy the 3 upper elements from `a` to the upper elements of the result."],["_mm_getcsr","Gets the unsigned 32-bit value of the MXCSR control and status register."],["_mm_hadd_epi16","Horizontally adds the adjacent pairs of values contained in 2 packed 128-bit vectors of `[8 x i16]`."],["_mm_hadd_epi32","Horizontally adds the adjacent pairs of values contained in 2 packed 128-bit vectors of `[4 x i32]`."],["_mm_hadd_pd","Horizontally adds adjacent pairs of double-precision (64-bit) floating-point elements in `a` and `b`, and pack the results."],["_mm_hadd_pi16","Horizontally adds the adjacent pairs of values contained in 2 packed 64-bit vectors of `[4 x i16]`."],["_mm_hadd_pi32","Horizontally adds the adjacent pairs of values contained in 2 packed 64-bit vectors of `[2 x i32]`."],["_mm_hadd_ps","Horizontally adds adjacent pairs of single-precision (32-bit) floating-point elements in `a` and `b`, and pack the results."],["_mm_hadds_epi16","Horizontally adds the adjacent pairs of values contained in 2 packed 128-bit vectors of `[8 x i16]`. Positive sums greater than 7FFFh are saturated to 7FFFh. Negative sums less than 8000h are saturated to 8000h."],["_mm_hadds_pi16","Horizontally adds the adjacent pairs of values contained in 2 packed 64-bit vectors of `[4 x i16]`. Positive sums greater than 7FFFh are saturated to 7FFFh. Negative sums less than 8000h are saturated to 8000h."],["_mm_hsub_epi16","Horizontally subtract the adjacent pairs of values contained in 2 packed 128-bit vectors of `[8 x i16]`."],["_mm_hsub_epi32","Horizontally subtract the adjacent pairs of values contained in 2 packed 128-bit vectors of `[4 x i32]`."],["_mm_hsub_pd","Horizontally subtract adjacent pairs of double-precision (64-bit) floating-point elements in `a` and `b`, and pack the results."],["_mm_hsub_pi16","Horizontally subtracts the adjacent pairs of values contained in 2 packed 64-bit vectors of `[4 x i16]`."],["_mm_hsub_pi32","Horizontally subtracts the adjacent pairs of values contained in 2 packed 64-bit vectors of `[2 x i32]`."],["_mm_hsub_ps","Horizontally adds adjacent pairs of single-precision (32-bit) floating-point elements in `a` and `b`, and pack the results."],["_mm_hsubs_epi16","Horizontally subtract the adjacent pairs of values contained in 2 packed 128-bit vectors of `[8 x i16]`. Positive differences greater than 7FFFh are saturated to 7FFFh. Negative differences less than 8000h are saturated to 8000h."],["_mm_hsubs_pi16","Horizontally subtracts the adjacent pairs of values contained in 2 packed 64-bit vectors of `[4 x i16]`. Positive differences greater than 7FFFh are saturated to 7FFFh. Negative differences less than 8000h are saturated to 8000h."],["_mm_i32gather_epi32","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm_i32gather_epi64","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm_i32gather_pd","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm_i32gather_ps","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm_i64gather_epi32","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm_i64gather_epi64","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm_i64gather_pd","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm_i64gather_ps","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8."],["_mm_insert_epi16","Returns a new vector where the `imm8` element of `a` is replaced with `i`."],["_mm_insert_epi32","Returns a copy of `a` with the 32-bit integer from `i` inserted at a location specified by `imm8`."],["_mm_insert_epi64","Returns a copy of `a` with the 64-bit integer from `i` inserted at a location specified by `imm8`."],["_mm_insert_epi8","Returns a copy of `a` with the 8-bit integer from `i` inserted at a location specified by `imm8`."],["_mm_insert_pi16","Copies data from the 64-bit vector of `[4 x i16]` to the destination, and inserts the lower 16-bits of an integer operand at the 16-bit offset specified by the immediate operand `n`."],["_mm_insert_ps","Select a single value in `a` to store at some position in `b`, Then zero elements according to `imm8`."],["_mm_insert_si64","Inserts the `[length:0]` bits of `y` into `x` at `index`."],["_mm_lddqu_si128","Loads 128-bits of integer data from unaligned memory. This intrinsic may perform better than `_mm_loadu_si128` when the data crosses a cache line boundary."],["_mm_lfence","Performs a serializing operation on all load-from-memory instructions that were issued prior to this instruction."],["_mm_load1_pd","Loads a double-precision (64-bit) floating-point element from memory into both elements of returned vector."],["_mm_load1_ps","Construct a `__m128` by duplicating the value read from `p` into all elements."],["_mm_load_pd","Loads 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into the returned vector. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated."],["_mm_load_pd1","Loads a double-precision (64-bit) floating-point element from memory into both elements of returned vector."],["_mm_load_ps","Loads four `f32` values from aligned memory into a `__m128`. If the pointer is not aligned to a 128-bit boundary (16 bytes) a general protection fault will be triggered (fatal program crash)."],["_mm_load_ps1","Alias for `_mm_load1_ps`"],["_mm_load_sd","Loads a 64-bit double-precision value to the low element of a 128-bit integer vector and clears the upper element."],["_mm_load_si128","Loads 128-bits of integer data from memory into a new vector."],["_mm_load_ss","Construct a `__m128` with the lowest element read from `p` and the other elements set to zero."],["_mm_loaddup_pd","Loads a double-precision (64-bit) floating-point element from memory into both elements of return vector."],["_mm_loadh_pd","Loads a double-precision value into the high-order bits of a 128-bit vector of `[2 x double]`. The low-order bits are copied from the low-order bits of the first operand."],["_mm_loadh_pi","Sets the upper two single-precision floating-point values with 64 bits of data loaded from the address `p`; the lower two values are passed through from `a`."],["_mm_loadl_epi64","Loads 64-bit integer from memory into first element of returned vector."],["_mm_loadl_pd","Loads a double-precision value into the low-order bits of a 128-bit vector of `[2 x double]`. The high-order bits are copied from the high-order bits of the first operand."],["_mm_loadl_pi","Loads two floats from `p` into the lower half of a `__m128`. The upper half is copied from the upper half of `a`."],["_mm_loadr_pd","Loads 2 double-precision (64-bit) floating-point elements from memory into the returned vector in reverse order. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated."],["_mm_loadr_ps","Loads four `f32` values from aligned memory into a `__m128` in reverse order."],["_mm_loadu_pd","Loads 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into the returned vector. `mem_addr` does not need to be aligned on any particular boundary."],["_mm_loadu_ps","Loads four `f32` values from memory into a `__m128`. There are no restrictions on memory alignment. For aligned memory `_mm_load_ps` may be faster."],["_mm_loadu_si128","Loads 128-bits of integer data from memory into a new vector."],["_mm_madd52hi_epu64","Multiply packed unsigned 52-bit integers in each 64-bit element of `b` and `c` to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`."],["_mm_madd52lo_epu64","Multiply packed unsigned 52-bit integers in each 64-bit element of `b` and `c` to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in `a`, and store the results in `dst`."],["_mm_madd_epi16","Multiplies and then horizontally add signed 16 bit integers in `a` and `b`."],["_mm_maddubs_epi16","Multiplies corresponding pairs of packed 8-bit unsigned integer values contained in the first source operand and packed 8-bit signed integer values contained in the second source operand, add pairs of contiguous products with signed saturation, and writes the 16-bit sums to the corresponding bits in the destination."],["_mm_maddubs_pi16","Multiplies corresponding pairs of packed 8-bit unsigned integer values contained in the first source operand and packed 8-bit signed integer values contained in the second source operand, adds pairs of contiguous products with signed saturation, and writes the 16-bit sums to the corresponding bits in the destination."],["_mm_mask_i32gather_epi32","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm_mask_i32gather_epi64","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm_mask_i32gather_pd","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm_mask_i32gather_ps","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm_mask_i64gather_epi32","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm_mask_i64gather_epi64","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm_mask_i64gather_pd","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm_mask_i64gather_ps","Returns values from `slice` at offsets determined by `offsets * scale`, where `scale` is between 1 and 8. If mask is set, load the value from `src` in that position instead."],["_mm_maskload_epi32","Loads packed 32-bit integers from memory pointed by `mem_addr` using `mask` (elements are zeroed out when the highest bit is not set in the corresponding element)."],["_mm_maskload_epi64","Loads packed 64-bit integers from memory pointed by `mem_addr` using `mask` (elements are zeroed out when the highest bit is not set in the corresponding element)."],["_mm_maskload_pd","Loads packed double-precision (64-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set)."],["_mm_maskload_ps","Loads packed single-precision (32-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set)."],["_mm_maskmove_si64","Conditionally copies the values from each 8-bit element in the first 64-bit integer vector operand to the specified memory location, as specified by the most significant bit in the corresponding element in the second 64-bit integer vector operand."],["_mm_maskmoveu_si128","Conditionally store 8-bit integer elements from `a` into memory using `mask`."],["_mm_maskstore_epi32","Stores packed 32-bit integers from `a` into memory pointed by `mem_addr` using `mask` (elements are not stored when the highest bit is not set in the corresponding element)."],["_mm_maskstore_epi64","Stores packed 64-bit integers from `a` into memory pointed by `mem_addr` using `mask` (elements are not stored when the highest bit is not set in the corresponding element)."],["_mm_maskstore_pd","Stores packed double-precision (64-bit) floating-point elements from `a` into memory using `mask`."],["_mm_maskstore_ps","Stores packed single-precision (32-bit) floating-point elements from `a` into memory using `mask`."],["_mm_max_epi16","Compares packed 16-bit integers in `a` and `b`, and returns the packed maximum values."],["_mm_max_epi32","Compares packed 32-bit integers in `a` and `b`, and returns packed maximum values."],["_mm_max_epi8","Compares packed 8-bit integers in `a` and `b` and returns packed maximum values in dst."],["_mm_max_epu16","Compares packed unsigned 16-bit integers in `a` and `b`, and returns packed maximum."],["_mm_max_epu32","Compares packed unsigned 32-bit integers in `a` and `b`, and returns packed maximum values."],["_mm_max_epu8","Compares packed unsigned 8-bit integers in `a` and `b`, and returns the packed maximum values."],["_mm_max_pd","Returns a new vector with the maximum values from corresponding elements in `a` and `b`."],["_mm_max_pi16","Compares the packed 16-bit signed integers of `a` and `b` writing the greatest value into the result."],["_mm_max_ps","Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and return the corresponding maximum values."],["_mm_max_pu8","Compares the packed 8-bit signed integers of `a` and `b` writing the greatest value into the result."],["_mm_max_sd","Returns a new vector with the low element of `a` replaced by the maximum of the lower elements of `a` and `b`."],["_mm_max_ss","Compares the first single-precision (32-bit) floating-point element of `a` and `b`, and return the maximum value in the first element of the return value, the other elements are copied from `a`."],["_mm_mfence","Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior to this instruction."],["_mm_min_epi16","Compares packed 16-bit integers in `a` and `b`, and returns the packed minimum values."],["_mm_min_epi32","Compares packed 32-bit integers in `a` and `b`, and returns packed minimum values."],["_mm_min_epi8","Compares packed 8-bit integers in `a` and `b` and returns packed minimum values in dst."],["_mm_min_epu16","Compares packed unsigned 16-bit integers in `a` and `b`, and returns packed minimum."],["_mm_min_epu32","Compares packed unsigned 32-bit integers in `a` and `b`, and returns packed minimum values."],["_mm_min_epu8","Compares packed unsigned 8-bit integers in `a` and `b`, and returns the packed minimum values."],["_mm_min_pd","Returns a new vector with the minimum values from corresponding elements in `a` and `b`."],["_mm_min_pi16","Compares the packed 16-bit signed integers of `a` and `b` writing the smallest value into the result."],["_mm_min_ps","Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and return the corresponding minimum values."],["_mm_min_pu8","Compares the packed 8-bit signed integers of `a` and `b` writing the smallest value into the result."],["_mm_min_sd","Returns a new vector with the low element of `a` replaced by the minimum of the lower elements of `a` and `b`."],["_mm_min_ss","Compares the first single-precision (32-bit) floating-point element of `a` and `b`, and return the minimum value in the first element of the return value, the other elements are copied from `a`."],["_mm_minpos_epu16","Finds the minimum unsigned 16-bit element in the 128-bit __m128i vector, returning a vector containing its value in its first position, and its index in its second position; all other elements are set to zero."],["_mm_move_epi64","Returns a vector where the low element is extracted from `a` and its upper element is zero."],["_mm_move_sd","Constructs a 128-bit floating-point vector of `[2 x double]`. The lower 64 bits are set to the lower 64 bits of the second parameter. The upper 64 bits are set to the upper 64 bits of the first parameter."],["_mm_move_ss","Returns a `__m128` with the first component from `b` and the remaining components from `a`."],["_mm_movedup_pd","Duplicate the low double-precision (64-bit) floating-point element from `a`."],["_mm_movehdup_ps","Duplicate odd-indexed single-precision (32-bit) floating-point elements from `a`."],["_mm_movehl_ps","Combine higher half of `a` and `b`. The highwe half of `b` occupies the lower half of result."],["_mm_moveldup_ps","Duplicate even-indexed single-precision (32-bit) floating-point elements from `a`."],["_mm_movelh_ps","Combine lower half of `a` and `b`. The lower half of `b` occupies the higher half of result."],["_mm_movemask_epi8","Returns a mask of the most significant bit of each element in `a`."],["_mm_movemask_pd","Returns a mask of the most significant bit of each element in `a`."],["_mm_movemask_pi8","Takes the most significant bit from each 8-bit element in a 64-bit integer vector to create a 16-bit mask value. Zero-extends the value to 32-bit integer and writes it to the destination."],["_mm_movemask_ps","Returns a mask of the most significant bit of each element in `a`."],["_mm_movepi64_pi64","Returns the lower 64 bits of a 128-bit integer vector as a 64-bit integer."],["_mm_movpi64_epi64","Moves the 64-bit operand to a 128-bit integer vector, zeroing the upper bits."],["_mm_mpsadbw_epu8","Subtracts 8-bit unsigned integer values and computes the absolute values of the differences to the corresponding bits in the destination. Then sums of the absolute differences are returned according to the bit fields in the immediate operand."],["_mm_mul_epi32","Multiplies the low 32-bit integers from each packed 64-bit element in `a` and `b`, and returns the signed 64-bit result."],["_mm_mul_epu32","Multiplies the low unsigned 32-bit integers from each packed 64-bit element in `a` and `b`."],["_mm_mul_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm_mul_ps","Multiplies __m128 vectors."],["_mm_mul_sd","Returns a new vector with the low element of `a` replaced by multiplying the low elements of `a` and `b`."],["_mm_mul_ss","Multiplies the first component of `a` and `b`, the other components are copied from `a`."],["_mm_mul_su32","Multiplies 32-bit unsigned integer values contained in the lower bits of the two 64-bit integer vectors and returns the 64-bit unsigned product."],["_mm_mulhi_epi16","Multiplies the packed 16-bit integers in `a` and `b`."],["_mm_mulhi_epu16","Multiplies the packed unsigned 16-bit integers in `a` and `b`."],["_mm_mulhi_pu16","Multiplies packed 16-bit unsigned integer values and writes the high-order 16 bits of each 32-bit product to the corresponding bits in the destination."],["_mm_mulhrs_epi16","Multiplies packed 16-bit signed integer values, truncate the 32-bit product to the 18 most significant bits by right-shifting, round the truncated value by adding 1, and write bits `[16:1]` to the destination."],["_mm_mulhrs_pi16","Multiplies packed 16-bit signed integer values, truncates the 32-bit products to the 18 most significant bits by right-shifting, rounds the truncated value by adding 1, and writes bits `[16:1]` to the destination."],["_mm_mullo_epi16","Multiplies the packed 16-bit integers in `a` and `b`."],["_mm_mullo_epi32","Multiplies the packed 32-bit integers in `a` and `b`, producing intermediate 64-bit integers, and returns the lowest 32-bit, whatever they might be, reinterpreted as a signed integer. While `pmulld __m128i::splat(2), __m128i::splat(2)` returns the obvious `__m128i::splat(4)`, due to wrapping arithmetic `pmulld __m128i::splat(i32::MAX), __m128i::splat(2)` would return a negative number."],["_mm_mullo_pi16","Multiplies packed 16-bit integer values and writes the low-order 16 bits of each 32-bit product to the corresponding bits in the destination."],["_mm_or_pd","Computes the bitwise OR of `a` and `b`."],["_mm_or_ps","Bitwise OR of packed single-precision (32-bit) floating-point elements."],["_mm_or_si128","Computes the bitwise OR of 128 bits (representing integer data) in `a` and `b`."],["_mm_packs_epi16","Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers using signed saturation."],["_mm_packs_epi32","Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers using signed saturation."],["_mm_packs_pi16","Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers using signed saturation."],["_mm_packs_pi32","Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers using signed saturation."],["_mm_packus_epi16","Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers using unsigned saturation."],["_mm_packus_epi32","Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers using unsigned saturation"],["_mm_pause","Provides a hint to the processor that the code sequence is a spin-wait loop."],["_mm_permute_pd","Shuffles double-precision (64-bit) floating-point elements in `a` using the control in `imm8`."],["_mm_permute_ps","Shuffles single-precision (32-bit) floating-point elements in `a` using the control in `imm8`."],["_mm_permutevar_pd","Shuffles double-precision (64-bit) floating-point elements in `a` using the control in `b`."],["_mm_permutevar_ps","Shuffles single-precision (32-bit) floating-point elements in `a` using the control in `b`."],["_mm_prefetch","Fetch the cache line that contains address `p` using the given `strategy`."],["_mm_rcp_ps","Returns the approximate reciprocal of packed single-precision (32-bit) floating-point elements in `a`."],["_mm_rcp_ss","Returns the approximate reciprocal of the first single-precision (32-bit) floating-point element in `a`, the other elements are unchanged."],["_mm_round_pd","Round the packed double-precision (64-bit) floating-point elements in `a` using the `rounding` parameter, and stores the results as packed double-precision floating-point elements. Rounding is done according to the rounding parameter, which can be one of:"],["_mm_round_ps","Round the packed single-precision (32-bit) floating-point elements in `a` using the `rounding` parameter, and stores the results as packed single-precision floating-point elements. Rounding is done according to the rounding parameter, which can be one of:"],["_mm_round_sd","Round the lower double-precision (64-bit) floating-point element in `b` using the `rounding` parameter, store the result as a double-precision floating-point element in the lower element of the intrinsic result, and copies the upper element from `a` to the upper element of the intrinsic result. Rounding is done according to the rounding parameter, which can be one of:"],["_mm_round_ss","Round the lower single-precision (32-bit) floating-point element in `b` using the `rounding` parameter, store the result as a single-precision floating-point element in the lower element of the intrinsic result, and copies the upper 3 packed elements from `a` to the upper elements of the instrinsic result. Rounding is done according to the rounding parameter, which can be one of:"],["_mm_rsqrt_ps","Returns the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in `a`."],["_mm_rsqrt_ss","Returns the approximate reciprocal square root of the fist single-precision (32-bit) floating-point elements in `a`, the other elements are unchanged."],["_mm_sad_epu8","Sum the absolute differences of packed unsigned 8-bit integers."],["_mm_sad_pu8","Subtracts the corresponding 8-bit unsigned integer values of the two 64-bit vector operands and computes the absolute value for each of the difference. Then sum of the 8 absolute differences is written to the bits `[15:0]` of the destination; the remaining bits `[63:16]` are cleared."],["_mm_set1_epi16","Broadcasts 16-bit integer `a` to all elements."],["_mm_set1_epi32","Broadcasts 32-bit integer `a` to all elements."],["_mm_set1_epi64","Initializes both values in a 128-bit vector of `[2 x i64]` with the specified 64-bit value."],["_mm_set1_epi64x","Broadcasts 64-bit integer `a` to all elements."],["_mm_set1_epi8","Broadcasts 8-bit integer `a` to all elements."],["_mm_set1_pd","Broadcasts double-precision (64-bit) floating-point value a to all elements of the return value."],["_mm_set1_pi16","Broadcasts 16-bit integer a to all all elements of dst."],["_mm_set1_pi32","Broadcasts 32-bit integer a to all all elements of dst."],["_mm_set1_pi8","Broadcasts 8-bit integer a to all all elements of dst."],["_mm_set1_ps","Construct a `__m128` with all element set to `a`."],["_mm_set_epi16","Sets packed 16-bit integers with the supplied values."],["_mm_set_epi32","Sets packed 32-bit integers with the supplied values."],["_mm_set_epi64","Initializes both 64-bit values in a 128-bit vector of `[2 x i64]` with the specified 64-bit integer values."],["_mm_set_epi64x","Sets packed 64-bit integers with the supplied values, from highest to lowest."],["_mm_set_epi8","Sets packed 8-bit integers with the supplied values."],["_mm_set_pd","Sets packed double-precision (64-bit) floating-point elements in the return value with the supplied values."],["_mm_set_pd1","Broadcasts double-precision (64-bit) floating-point value a to all elements of the return value."],["_mm_set_pi16","Sets packed 16-bit integers in dst with the supplied values."],["_mm_set_pi32","Sets packed 32-bit integers in dst with the supplied values."],["_mm_set_pi8","Sets packed 8-bit integers in dst with the supplied values."],["_mm_set_ps","Construct a `__m128` from four floating point values highest to lowest."],["_mm_set_ps1","Alias for `_mm_set1_ps`"],["_mm_set_sd","Copies double-precision (64-bit) floating-point element `a` to the lower element of the packed 64-bit return value."],["_mm_set_ss","Construct a `__m128` with the lowest element set to `a` and the rest set to zero."],["_mm_setcsr","Sets the MXCSR register with the 32-bit unsigned integer value."],["_mm_setr_epi16","Sets packed 16-bit integers with the supplied values in reverse order."],["_mm_setr_epi32","Sets packed 32-bit integers with the supplied values in reverse order."],["_mm_setr_epi64","Constructs a 128-bit integer vector, initialized in reverse order with the specified 64-bit integral values."],["_mm_setr_epi8","Sets packed 8-bit integers with the supplied values in reverse order."],["_mm_setr_pd","Sets packed double-precision (64-bit) floating-point elements in the return value with the supplied values in reverse order."],["_mm_setr_pi16","Sets packed 16-bit integers in dst with the supplied values in reverse order."],["_mm_setr_pi32","Sets packed 32-bit integers in dst with the supplied values in reverse order."],["_mm_setr_pi8","Sets packed 8-bit integers in dst with the supplied values in reverse order."],["_mm_setr_ps","Construct a `__m128` from four floating point values lowest to highest."],["_mm_setzero_pd","Returns packed double-precision (64-bit) floating-point elements with all zeros."],["_mm_setzero_ps","Construct a `__m128` with all elements initialized to zero."],["_mm_setzero_si128","Returns a vector with all elements set to zero."],["_mm_setzero_si64","Constructs a 64-bit integer vector initialized to zero."],["_mm_sfence","Performs a serializing operation on all store-to-memory instructions that were issued prior to this instruction."],["_mm_sha1msg1_epu32","Performs an intermediate calculation for the next four SHA1 message values (unsigned 32-bit integers) using previous message values from `a` and `b`, and returning the result."],["_mm_sha1msg2_epu32","Performs the final calculation for the next four SHA1 message values (unsigned 32-bit integers) using the intermediate result in `a` and the previous message values in `b`, and returns the result."],["_mm_sha1nexte_epu32","Calculate SHA1 state variable E after four rounds of operation from the current SHA1 state variable `a`, add that value to the scheduled values (unsigned 32-bit integers) in `b`, and returns the result."],["_mm_sha1rnds4_epu32","Performs four rounds of SHA1 operation using an initial SHA1 state (A,B,C,D) from `a` and some pre-computed sum of the next 4 round message values (unsigned 32-bit integers), and state variable E from `b`, and return the updated SHA1 state (A,B,C,D). `func` contains the logic functions and round constants."],["_mm_sha256msg1_epu32","Performs an intermediate calculation for the next four SHA256 message values (unsigned 32-bit integers) using previous message values from `a` and `b`, and return the result."],["_mm_sha256msg2_epu32","Performs the final calculation for the next four SHA256 message values (unsigned 32-bit integers) using previous message values from `a` and `b`, and return the result."],["_mm_sha256rnds2_epu32","Performs 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H) from `a`, an initial SHA256 state (A,B,E,F) from `b`, and a pre-computed sum of the next 2 round message values (unsigned 32-bit integers) and the corresponding round constants from `k`, and store the updated SHA256 state (A,B,E,F) in dst."],["_mm_shuffle_epi32","Shuffles 32-bit integers in `a` using the control in `imm8`."],["_mm_shuffle_epi8","Shuffles bytes from `a` according to the content of `b`."],["_mm_shuffle_pd","Constructs a 128-bit floating-point vector of `[2 x double]` from two 128-bit vector parameters of `[2 x double]`, using the immediate-value parameter as a specifier."],["_mm_shuffle_pi16","Shuffles the 4 16-bit integers from a 64-bit integer vector to the destination, as specified by the immediate value operand."],["_mm_shuffle_pi8","Shuffles packed 8-bit integers in `a` according to shuffle control mask in the corresponding 8-bit element of `b`, and returns the results"],["_mm_shuffle_ps","Shuffles packed single-precision (32-bit) floating-point elements in `a` and `b` using `mask`."],["_mm_shufflehi_epi16","Shuffles 16-bit integers in the high 64 bits of `a` using the control in `imm8`."],["_mm_shufflelo_epi16","Shuffles 16-bit integers in the low 64 bits of `a` using the control in `imm8`."],["_mm_sign_epi16","Negates packed 16-bit integers in `a` when the corresponding signed 16-bit integer in `b` is negative, and returns the results. Elements in result are zeroed out when the corresponding element in `b` is zero."],["_mm_sign_epi32","Negates packed 32-bit integers in `a` when the corresponding signed 32-bit integer in `b` is negative, and returns the results. Element in result are zeroed out when the corresponding element in `b` is zero."],["_mm_sign_epi8","Negates packed 8-bit integers in `a` when the corresponding signed 8-bit integer in `b` is negative, and returns the result. Elements in result are zeroed out when the corresponding element in `b` is zero."],["_mm_sign_pi16","Negates packed 16-bit integers in `a` when the corresponding signed 16-bit integer in `b` is negative, and returns the results. Element in result are zeroed out when the corresponding element in `b` is zero."],["_mm_sign_pi32","Negates packed 32-bit integers in `a` when the corresponding signed 32-bit integer in `b` is negative, and returns the results. Element in result are zeroed out when the corresponding element in `b` is zero."],["_mm_sign_pi8","Negates packed 8-bit integers in `a` when the corresponding signed 8-bit integer in `b` is negative, and returns the results. Element in result are zeroed out when the corresponding element in `b` is zero."],["_mm_sll_epi16","Shifts packed 16-bit integers in `a` left by `count` while shifting in zeros."],["_mm_sll_epi32","Shifts packed 32-bit integers in `a` left by `count` while shifting in zeros."],["_mm_sll_epi64","Shifts packed 64-bit integers in `a` left by `count` while shifting in zeros."],["_mm_slli_epi16","Shifts packed 16-bit integers in `a` left by `imm8` while shifting in zeros."],["_mm_slli_epi32","Shifts packed 32-bit integers in `a` left by `imm8` while shifting in zeros."],["_mm_slli_epi64","Shifts packed 64-bit integers in `a` left by `imm8` while shifting in zeros."],["_mm_slli_si128","Shifts `a` left by `imm8` bytes while shifting in zeros."],["_mm_sllv_epi32","Shifts packed 32-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and returns the result."],["_mm_sllv_epi64","Shifts packed 64-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and returns the result."],["_mm_sqrt_pd","Returns a new vector with the square root of each of the values in `a`."],["_mm_sqrt_ps","Returns the square root of packed single-precision (32-bit) floating-point elements in `a`."],["_mm_sqrt_sd","Returns a new vector with the low element of `a` replaced by the square root of the lower element `b`."],["_mm_sqrt_ss","Returns the square root of the first single-precision (32-bit) floating-point element in `a`, the other elements are unchanged."],["_mm_sra_epi16","Shifts packed 16-bit integers in `a` right by `count` while shifting in sign bits."],["_mm_sra_epi32","Shifts packed 32-bit integers in `a` right by `count` while shifting in sign bits."],["_mm_srai_epi16","Shifts packed 16-bit integers in `a` right by `imm8` while shifting in sign bits."],["_mm_srai_epi32","Shifts packed 32-bit integers in `a` right by `imm8` while shifting in sign bits."],["_mm_srav_epi32","Shifts packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in sign bits."],["_mm_srl_epi16","Shifts packed 16-bit integers in `a` right by `count` while shifting in zeros."],["_mm_srl_epi32","Shifts packed 32-bit integers in `a` right by `count` while shifting in zeros."],["_mm_srl_epi64","Shifts packed 64-bit integers in `a` right by `count` while shifting in zeros."],["_mm_srli_epi16","Shifts packed 16-bit integers in `a` right by `imm8` while shifting in zeros."],["_mm_srli_epi32","Shifts packed 32-bit integers in `a` right by `imm8` while shifting in zeros."],["_mm_srli_epi64","Shifts packed 64-bit integers in `a` right by `imm8` while shifting in zeros."],["_mm_srli_si128","Shifts `a` right by `imm8` bytes while shifting in zeros."],["_mm_srlv_epi32","Shifts packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,"],["_mm_srlv_epi64","Shifts packed 64-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,"],["_mm_store1_pd","Stores the lower double-precision (64-bit) floating-point element from `a` into 2 contiguous elements in memory. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated."],["_mm_store1_ps","Stores the lowest 32 bit float of `a` repeated four times into aligned memory."],["_mm_store_pd","Stores 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `a` into memory. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated."],["_mm_store_pd1","Stores the lower double-precision (64-bit) floating-point element from `a` into 2 contiguous elements in memory. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated."],["_mm_store_ps","Stores four 32-bit floats into aligned memory."],["_mm_store_ps1","Alias for `_mm_store1_ps`"],["_mm_store_sd","Stores the lower 64 bits of a 128-bit vector of `[2 x double]` to a memory location."],["_mm_store_si128","Stores 128-bits of integer data from `a` into memory."],["_mm_store_ss","Stores the lowest 32 bit float of `a` into memory."],["_mm_storeh_pd","Stores the upper 64 bits of a 128-bit vector of `[2 x double]` to a memory location."],["_mm_storeh_pi","Stores the upper half of `a` (64 bits) into memory."],["_mm_storel_epi64","Stores the lower 64-bit integer `a` to a memory location."],["_mm_storel_pd","Stores the lower 64 bits of a 128-bit vector of `[2 x double]` to a memory location."],["_mm_storel_pi","Stores the lower half of `a` (64 bits) into memory."],["_mm_storer_pd","Stores 2 double-precision (64-bit) floating-point elements from `a` into memory in reverse order. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated."],["_mm_storer_ps","Stores four 32-bit floats into aligned memory in reverse order."],["_mm_storeu_pd","Stores 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `a` into memory. `mem_addr` does not need to be aligned on any particular boundary."],["_mm_storeu_ps","Stores four 32-bit floats into memory. There are no restrictions on memory alignment. For aligned memory `_mm_store_ps` may be faster."],["_mm_storeu_si128","Stores 128-bits of integer data from `a` into memory."],["_mm_stream_pd","Stores a 128-bit floating point vector of `[2 x double]` to a 128-bit aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)."],["_mm_stream_pi","Stores 64-bits of integer data from a into memory using a non-temporal memory hint."],["_mm_stream_ps","Stores `a` into the memory at `mem_addr` using a non-temporal memory hint."],["_mm_stream_sd","Non-temporal store of `a.0` into `p`."],["_mm_stream_si128","Stores a 128-bit integer vector to a 128-bit aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)."],["_mm_stream_si32","Stores a 32-bit integer value in the specified memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)."],["_mm_stream_si64","Stores a 64-bit integer value in the specified memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)."],["_mm_stream_ss","Non-temporal store of `a.0` into `p`."],["_mm_sub_epi16","Subtracts packed 16-bit integers in `b` from packed 16-bit integers in `a`."],["_mm_sub_epi32","Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`."],["_mm_sub_epi64","Subtract packed 64-bit integers in `b` from packed 64-bit integers in `a`."],["_mm_sub_epi8","Subtracts packed 8-bit integers in `b` from packed 8-bit integers in `a`."],["_mm_sub_pd","Subtract packed double-precision (64-bit) floating-point elements in `b` from `a`."],["_mm_sub_pi16","Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`."],["_mm_sub_pi32","Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`."],["_mm_sub_pi8","Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`."],["_mm_sub_ps","Subtracts __m128 vectors."],["_mm_sub_sd","Returns a new vector with the low element of `a` replaced by subtracting the low element by `b` from the low element of `a`."],["_mm_sub_si64","Subtracts signed or unsigned 64-bit integer values and writes the difference to the corresponding bits in the destination."],["_mm_sub_ss","Subtracts the first component of `b` from `a`, the other components are copied from `a`."],["_mm_subs_epi16","Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a` using saturation."],["_mm_subs_epi8","Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a` using saturation."],["_mm_subs_epu16","Subtract packed unsigned 16-bit integers in `b` from packed unsigned 16-bit integers in `a` using saturation."],["_mm_subs_epu8","Subtract packed unsigned 8-bit integers in `b` from packed unsigned 8-bit integers in `a` using saturation."],["_mm_subs_pi16","Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a` using saturation."],["_mm_subs_pi8","Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a` using saturation."],["_mm_subs_pu16","Subtract packed unsigned 16-bit integers in `b` from packed unsigned 16-bit integers in `a` using saturation."],["_mm_subs_pu8","Subtract packed unsigned 8-bit integers in `b` from packed unsigned 8-bit integers in `a` using saturation."],["_mm_test_all_ones","Tests whether the specified bits in `a` 128-bit integer vector are all ones."],["_mm_test_all_zeros","Tests whether the specified bits in a 128-bit integer vector are all zeros."],["_mm_test_mix_ones_zeros","Tests whether the specified bits in a 128-bit integer vector are neither all zeros nor all ones."],["_mm_testc_pd","Computes the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `CF` value."],["_mm_testc_ps","Computes the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `CF` value."],["_mm_testc_si128","Tests whether the specified bits in a 128-bit integer vector are all ones."],["_mm_testnzc_pd","Computes the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0."],["_mm_testnzc_ps","Computes the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0."],["_mm_testnzc_si128","Tests whether the specified bits in a 128-bit integer vector are neither all zeros nor all ones."],["_mm_testz_pd","Computes the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `ZF` value."],["_mm_testz_ps","Computes the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `ZF` value."],["_mm_testz_si128","Tests whether the specified bits in a 128-bit integer vector are all zeros."],["_mm_tzcnt_32","Counts the number of trailing least significant zero bits."],["_mm_tzcnt_64","Counts the number of trailing least significant zero bits."],["_mm_ucomieq_sd","Compares the lower element of `a` and `b` for equality."],["_mm_ucomieq_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if they are equal, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN."],["_mm_ucomige_sd","Compares the lower element of `a` and `b` for greater-than-or-equal."],["_mm_ucomige_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is greater than or equal to the one from `b`, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN."],["_mm_ucomigt_sd","Compares the lower element of `a` and `b` for greater-than."],["_mm_ucomigt_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is greater than the one from `b`, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN."],["_mm_ucomile_sd","Compares the lower element of `a` and `b` for less-than-or-equal."],["_mm_ucomile_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is less than or equal to the one from `b`, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN."],["_mm_ucomilt_sd","Compares the lower element of `a` and `b` for less-than."],["_mm_ucomilt_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is less than the one from `b`, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN."],["_mm_ucomineq_sd","Compares the lower element of `a` and `b` for not-equal."],["_mm_ucomineq_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if they are not equal, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN."],["_mm_undefined_pd","Returns vector of type __m128d with undefined elements."],["_mm_undefined_ps","Returns vector of type __m128 with undefined elements."],["_mm_undefined_si128","Returns vector of type __m128i with undefined elements."],["_mm_unpackhi_epi16","Unpacks and interleave 16-bit integers from the high half of `a` and `b`."],["_mm_unpackhi_epi32","Unpacks and interleave 32-bit integers from the high half of `a` and `b`."],["_mm_unpackhi_epi64","Unpacks and interleave 64-bit integers from the high half of `a` and `b`."],["_mm_unpackhi_epi8","Unpacks and interleave 8-bit integers from the high half of `a` and `b`."],["_mm_unpackhi_pd","The resulting `__m128d` element is composed by the low-order values of the two `__m128d` interleaved input elements, i.e.:"],["_mm_unpackhi_pi16","Unpacks the upper two elements from two `i16x4` vectors and interleaves them into the result: `[a.2, b.2, a.3, b.3]`."],["_mm_unpackhi_pi32","Unpacks the upper element from two `i32x2` vectors and interleaves them into the result: `[a.1, b.1]`."],["_mm_unpackhi_pi8","Unpacks the upper four elements from two `i8x8` vectors and interleaves them into the result: `[a.4, b.4, a.5, b.5, a.6, b.6, a.7, b.7]`."],["_mm_unpackhi_ps","Unpacks and interleave single-precision (32-bit) floating-point elements from the higher half of `a` and `b`."],["_mm_unpacklo_epi16","Unpacks and interleave 16-bit integers from the low half of `a` and `b`."],["_mm_unpacklo_epi32","Unpacks and interleave 32-bit integers from the low half of `a` and `b`."],["_mm_unpacklo_epi64","Unpacks and interleave 64-bit integers from the low half of `a` and `b`."],["_mm_unpacklo_epi8","Unpacks and interleave 8-bit integers from the low half of `a` and `b`."],["_mm_unpacklo_pd","The resulting `__m128d` element is composed by the high-order values of the two `__m128d` interleaved input elements, i.e.:"],["_mm_unpacklo_pi16","Unpacks the lower two elements from two `i16x4` vectors and interleaves them into the result: `[a.0 b.0 a.1 b.1]`."],["_mm_unpacklo_pi32","Unpacks the lower element from two `i32x2` vectors and interleaves them into the result: `[a.0, b.0]`."],["_mm_unpacklo_pi8","Unpacks the lower four elements from two `i8x8` vectors and interleaves them into the result: `[a.0, b.0, a.1, b.1, a.2, b.2, a.3, b.3]`."],["_mm_unpacklo_ps","Unpacks and interleave single-precision (32-bit) floating-point elements from the lower half of `a` and `b`."],["_mm_xor_pd","Computes the bitwise OR of `a` and `b`."],["_mm_xor_ps","Bitwise exclusive OR of packed single-precision (32-bit) floating-point elements."],["_mm_xor_si128","Computes the bitwise XOR of 128 bits (representing integer data) in `a` and `b`."],["_mulx_u32","Unsigned multiply without affecting flags."],["_mulx_u64","Unsigned multiply without affecting flags."],["_pdep_u32","Scatter contiguous low order bits of `a` to the result at the positions specified by the `mask`."],["_pdep_u64","Scatter contiguous low order bits of `a` to the result at the positions specified by the `mask`."],["_pext_u32","Gathers the bits of `x` specified by the `mask` into the contiguous low order bit positions of the result."],["_pext_u64","Gathers the bits of `x` specified by the `mask` into the contiguous low order bit positions of the result."],["_popcnt32","Counts the bits that are set."],["_popcnt64","Counts the bits that are set."],["_rdrand16_step","Read a hardware generated 16-bit random value and store the result in val. Returns 1 if a random value was generated, and 0 otherwise."],["_rdrand32_step","Read a hardware generated 32-bit random value and store the result in val. Returns 1 if a random value was generated, and 0 otherwise."],["_rdrand64_step","Read a hardware generated 64-bit random value and store the result in val. Returns 1 if a random value was generated, and 0 otherwise."],["_rdseed16_step","Read a 16-bit NIST SP800-90B and SP800-90C compliant random value and store in val. Return 1 if a random value was generated, and 0 otherwise."],["_rdseed32_step","Read a 32-bit NIST SP800-90B and SP800-90C compliant random value and store in val. Return 1 if a random value was generated, and 0 otherwise."],["_rdseed64_step","Read a 64-bit NIST SP800-90B and SP800-90C compliant random value and store in val. Return 1 if a random value was generated, and 0 otherwise."],["_rdtsc","Reads the current value of the processorâ€™s time-stamp counter."],["_subborrow_u32","Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in` (carry or overflow flag), and store the unsigned 32-bit result in `out`, and the carry-out is returned (carry or overflow flag)."],["_subborrow_u64","Adds unsigned 64-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in`. (carry or overflow flag), and store the unsigned 64-bit result in `out`, and the carry-out is returned (carry or overflow flag)."],["_t1mskc_u32","Clears all bits below the least significant zero of `x` and sets all other bits."],["_t1mskc_u64","Clears all bits below the least significant zero of `x` and sets all other bits."],["_tzcnt_u32","Counts the number of trailing least significant zero bits."],["_tzcnt_u64","Counts the number of trailing least significant zero bits."],["_tzmsk_u32","Sets all bits below the least significant one of `x` and clears all other bits."],["_tzmsk_u64","Sets all bits below the least significant one of `x` and clears all other bits."],["_xabort","Forces a restricted transactional memory (RTM) region to abort."],["_xabort_code","Retrieves the parameter passed to [`_xabort`] when [`_xbegin`]'s status has the `_XABORT_EXPLICIT` flag set."],["_xbegin","Specifies the start of a restricted transactional memory (RTM) code region and returns a value indicating status."],["_xend","Specifies the end of a restricted transactional memory (RTM) code region."],["_xgetbv","Reads the contents of the extended control register `XCR` specified in `xcr_no`."],["_xrstor","Performs a full or partial restore of the enabled processor states using the state information stored in memory at `mem_addr`."],["_xrstor64","Performs a full or partial restore of the enabled processor states using the state information stored in memory at `mem_addr`."],["_xrstors","Performs a full or partial restore of the enabled processor states using the state information stored in memory at `mem_addr`."],["_xrstors64","Performs a full or partial restore of the enabled processor states using the state information stored in memory at `mem_addr`."],["_xsave","Performs a full or partial save of the enabled processor states to memory at `mem_addr`."],["_xsave64","Performs a full or partial save of the enabled processor states to memory at `mem_addr`."],["_xsavec","Performs a full or partial save of the enabled processor states to memory at `mem_addr`."],["_xsavec64","Performs a full or partial save of the enabled processor states to memory at `mem_addr`."],["_xsaveopt","Performs a full or partial save of the enabled processor states to memory at `mem_addr`."],["_xsaveopt64","Performs a full or partial save of the enabled processor states to memory at `mem_addr`."],["_xsaves","Performs a full or partial save of the enabled processor states to memory at `mem_addr`"],["_xsaves64","Performs a full or partial save of the enabled processor states to memory at `mem_addr`"],["_xsetbv","Copies 64-bits from `val` to the extended control register (`XCR`) specified by `a`."],["_xtest","Queries whether the processor is executing in a transactional region identified by restricted transactional memory (RTM) or hardware lock elision (HLE)."],["cmpxchg16b","Compares and exchange 16 bytes (128 bits) of data atomically."],["has_cpuid","Does the host support the `cpuid` instruction?"],["ud2","Generates the trap instruction `UD2`"]],"struct":[["CpuidResult","Result of the `cpuid` instruction."],["__m128","128-bit wide set of four `f32` types, x86-specific"],["__m128d","128-bit wide set of two `f64` types, x86-specific"],["__m128i","128-bit wide integer vector type, x86-specific"],["__m256","256-bit wide set of eight `f32` types, x86-specific"],["__m256d","256-bit wide set of four `f64` types, x86-specific"],["__m256i","256-bit wide integer vector type, x86-specific"],["__m512","512-bit wide set of sixteen `f32` types, x86-specific"],["__m512d","512-bit wide set of eight `f64` types, x86-specific"],["__m512i","512-bit wide integer vector type, x86-specific"],["__m64","64-bit wide integer vector type, x86-specific"]],"type":[["__mmask16","The `__mmask16` type used in AVX-512 intrinsics, a 16-bit integer"]]});